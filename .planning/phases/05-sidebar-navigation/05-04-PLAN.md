---
phase: 05-sidebar-navigation
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - sidekiq-webapp/src/components/sidebar/sidebar-search.tsx
  - sidekiq-webapp/src/hooks/use-thread-search.ts
  - sidekiq-webapp/src/components/sidebar/sidebar.tsx
  - sidekiq-webapp/src/components/sidebar/sidebar-thread-list.tsx
  - sidekiq-webapp/src/components/sidebar/index.ts
autonomous: true

must_haves:
  truths:
    - "Search input is visible at top of sidebar (below New Chat)"
    - "Typing in search filters threads by title with fuzzy matching"
    - "Search results show flat list (no date grouping)"
    - "Matching text is highlighted in search results"
    - "Empty search shows 'No conversations found' message"
    - "Search is debounced (~200ms) for performance"
  artifacts:
    - path: "sidekiq-webapp/src/components/sidebar/sidebar-search.tsx"
      provides: "Search input component"
      exports: ["SidebarSearch"]
    - path: "sidekiq-webapp/src/hooks/use-thread-search.ts"
      provides: "Fuzzy search hook with debounce"
      exports: ["useThreadSearch"]
  key_links:
    - from: "use-thread-search.ts"
      to: "fuse.js"
      via: "Fuse constructor and search"
      pattern: "new Fuse"
    - from: "sidebar.tsx"
      to: "sidebar-search.tsx"
      via: "component composition"
      pattern: "<SidebarSearch"
---

<objective>
Create thread search functionality with fuzzy matching and integrate into sidebar.

Purpose: Allow users to quickly find conversations by title using typo-tolerant search.
Output: SidebarSearch component and useThreadSearch hook, integrated into sidebar and thread list.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sidebar-navigation/05-CONTEXT.md
@.planning/phases/05-sidebar-navigation/05-RESEARCH.md
@.planning/phases/05-sidebar-navigation/05-01-SUMMARY.md
@sidekiq-webapp/src/components/model-picker/model-picker-content.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thread search hook</name>
  <files>sidekiq-webapp/src/hooks/use-thread-search.ts</files>
  <action>
Create `use-thread-search.ts` with:

1. **Thread type (match thread.list return):**
```typescript
interface Thread {
  id: string;
  title: string | null;
  isPinned: boolean;
  isArchived: boolean;
  lastActivityAt: Date;
  messageCount: number;
}
```

2. **Hook interface:**
```typescript
interface UseThreadSearchResult {
  query: string;
  setQuery: (query: string) => void;
  results: Thread[];
  isSearching: boolean; // True while debouncing
  highlightMatch: (text: string) => React.ReactNode; // For highlighting matches
}
```

3. **Implementation:**
```typescript
import { useState, useEffect, useMemo, useCallback } from "react";
import Fuse from "fuse.js";

export function useThreadSearch(threads: Thread[]): UseThreadSearchResult {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");

  // Debounce search query (200ms per CONTEXT.md)
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedQuery(query), 200);
    return () => clearTimeout(timer);
  }, [query]);

  // Create Fuse instance (memoized)
  const fuse = useMemo(
    () =>
      new Fuse(threads, {
        keys: ["title"],
        threshold: 0.4, // Per Phase 4 pattern - allows typos
        ignoreLocation: true,
        includeMatches: true, // For highlighting
      }),
    [threads]
  );

  // Get search results
  const searchResults = useMemo(() => {
    if (!debouncedQuery.trim()) return null; // null = no search active
    return fuse.search(debouncedQuery);
  }, [fuse, debouncedQuery]);

  const results = useMemo(() => {
    if (searchResults === null) return threads; // Return all threads when not searching
    return searchResults.map((result) => result.item);
  }, [searchResults, threads]);

  // Highlight matching text in title
  const highlightMatch = useCallback(
    (text: string): React.ReactNode => {
      if (!debouncedQuery.trim() || !text) return text;

      // Find the matching result to get match indices
      const matchResult = searchResults?.find((r) => r.item.title === text);
      if (!matchResult?.matches?.[0]?.indices) return text;

      const indices = matchResult.matches[0].indices;
      const parts: React.ReactNode[] = [];
      let lastIndex = 0;

      indices.forEach(([start, end], i) => {
        // Add non-matching text before this match
        if (start > lastIndex) {
          parts.push(text.slice(lastIndex, start));
        }
        // Add highlighted match
        parts.push(
          <mark key={i} className="bg-yellow-500/30 rounded px-0.5">
            {text.slice(start, end + 1)}
          </mark>
        );
        lastIndex = end + 1;
      });

      // Add remaining text after last match
      if (lastIndex < text.length) {
        parts.push(text.slice(lastIndex));
      }

      return <>{parts}</>;
    },
    [debouncedQuery, searchResults]
  );

  return {
    query,
    setQuery,
    results,
    isSearching: query !== debouncedQuery,
    highlightMatch,
  };
}
```

4. **Key points:**
   - threshold: 0.4 matches Phase 4 model picker pattern
   - includeMatches: true enables highlighting
   - Returns null for searchResults when query empty (distinguishes "no search" from "no results")
   - highlightMatch function for rendering highlighted titles

Add JSDoc for the hook.
  </action>
  <verify>TypeScript compiles: `cd sidekiq-webapp && pnpm tsc --noEmit`</verify>
  <done>Hook exports useThreadSearch with fuzzy search, debounce, and highlight function</done>
</task>

<task type="auto">
  <name>Task 2: Create SidebarSearch component</name>
  <files>sidekiq-webapp/src/components/sidebar/sidebar-search.tsx</files>
  <action>
Create `sidebar-search.tsx` with:

1. **Props interface:**
```typescript
interface SidebarSearchProps {
  query: string;
  onQueryChange: (query: string) => void;
  inputRef?: React.RefObject<HTMLInputElement>;
}
```

2. **Implementation:**
```tsx
import { Search, X } from "lucide-react";
import { Input } from "@sidekiq/components/ui/input";

/**
 * Search input for filtering threads by title.
 * Always visible at top of sidebar below New Chat.
 */
export function SidebarSearch({
  query,
  onQueryChange,
  inputRef,
}: SidebarSearchProps) {
  return (
    <div className="relative px-3 py-2">
      <Search className="absolute left-5 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
      <Input
        ref={inputRef}
        type="text"
        placeholder="Search conversations..."
        value={query}
        onChange={(e) => onQueryChange(e.target.value)}
        className="pl-8 pr-8 h-9 bg-muted/50 border-0 focus-visible:ring-1"
      />
      {query && (
        <button
          onClick={() => onQueryChange("")}
          className="absolute right-5 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </div>
  );
}
```

3. **Features:**
   - Search icon on left
   - Clear button (X) on right when query is not empty
   - Subtle styling (muted background, minimal border)
   - inputRef for keyboard shortcut focus (Cmd+K)

Add JSDoc for the component.
  </action>
  <verify>TypeScript compiles: `cd sidekiq-webapp && pnpm tsc --noEmit`</verify>
  <done>SidebarSearch renders input with search icon, clear button, accepts inputRef</done>
</task>

<task type="auto">
  <name>Task 3: Integrate search into Sidebar and ThreadList</name>
  <files>
    sidekiq-webapp/src/components/sidebar/sidebar.tsx,
    sidekiq-webapp/src/components/sidebar/sidebar-thread-list.tsx,
    sidekiq-webapp/src/components/sidebar/index.ts
  </files>
  <action>
**Update sidebar.tsx:**

1. **State at sidebar level:**
```typescript
const [searchQuery, setSearchQuery] = useState("");
const searchInputRef = useRef<HTMLInputElement>(null);
```

2. **Integrate keyboard shortcuts:**
```typescript
import { useKeyboardShortcuts } from "@sidekiq/hooks/use-keyboard-shortcuts";

useKeyboardShortcuts({
  onNewChat: () => router.push("/chat"),
  onToggleSidebar: toggle,
  onFocusSearch: () => searchInputRef.current?.focus(),
});
```

3. **Add SidebarSearch to layout:**
```tsx
<SidebarHeader isCollapsed={isCollapsed} />

{/* Search */}
<SidebarSearch
  query={searchQuery}
  onQueryChange={setSearchQuery}
  inputRef={searchInputRef}
/>

{/* Thread list */}
<div className="flex-1 overflow-hidden">
  <SidebarThreadList searchQuery={searchQuery} />
</div>
```

**Update sidebar-thread-list.tsx:**

1. **Accept searchQuery prop:**
```typescript
interface SidebarThreadListProps {
  searchQuery?: string;
}
```

2. **Use search hook:**
```typescript
import { useThreadSearch } from "@sidekiq/hooks/use-thread-search";

const threadsQuery = api.thread.list.useQuery();
const threads = threadsQuery.data ?? [];

const { results, highlightMatch } = useThreadSearch(threads);
const isSearchActive = searchQuery?.trim();
```

3. **Conditional rendering logic:**
```typescript
// When searching: show flat list (no grouping)
// When not searching: show grouped list
const displayItems = useMemo(() => {
  if (isSearchActive) {
    // Flat list for search - just threads, no headers
    return results.map((thread) => ({ type: "thread" as const, thread }));
  } else {
    // Grouped list - use date grouping
    return flattenGroupsForVirtualization(groupedThreads);
  }
}, [isSearchActive, results, groupedThreads]);
```

4. **Apply highlighting via CSS override (do NOT modify ThreadItem):**

The simplest approach is to NOT modify ThreadItem from Phase 3. Instead, use CSS to apply highlighting:

```tsx
{item.type === "thread" && (
  <div className={isSearchActive ? "search-result-item" : undefined}>
    <ThreadItem
      thread={item.thread}
      isActive={item.thread.id === activeThreadId}
      activeThreadId={activeThreadId}
    />
  </div>
)}
```

For highlighting matches in the title, add a separate visual indicator below the thread item during search:
```tsx
{item.type === "thread" && isSearchActive && (
  <div className="px-3 -mt-1 mb-1">
    <span className="text-xs text-muted-foreground">
      {highlightMatch(item.thread.title ?? "New conversation")}
    </span>
  </div>
)}
```

This keeps ThreadItem unchanged and avoids modifying Phase 3 components.

6. **Empty search results state:**
```tsx
{isSearchActive && results.length === 0 && (
  <div className="px-3 py-8 text-center text-sm text-muted-foreground">
    No conversations found
  </div>
)}
```

**Update index.ts:**
```typescript
export { SidebarSearch } from "./sidebar-search";
```

Add/update JSDoc for components.
  </action>
  <verify>
1. TypeScript compiles: `cd sidekiq-webapp && pnpm tsc --noEmit`
2. Lint passes: `pnpm lint`
  </verify>
  <done>Search integrated into sidebar, filters threads with highlighting, Cmd+K focuses search</done>
</task>

</tasks>

<verification>
1. All files created/updated with proper TypeScript types
2. No TypeScript errors: `pnpm tsc --noEmit`
3. Lint passes: `pnpm lint`
4. Search input visible below New Chat in sidebar
5. Typing filters threads with fuzzy matching
6. Search results show flat list (no date groups)
7. Matching text highlighted in results
8. Clear button (X) clears search
9. Cmd+K focuses search input
10. "No conversations found" shows when no matches
</verification>

<success_criteria>
- SidebarSearch component renders at top of sidebar
- Typing in search filters threads by title
- Fuzzy matching works (typos tolerated)
- Search is debounced (no jank during typing)
- Results show as flat list (no date grouping during search)
- Matching text highlighted with subtle background
- Clear button clears search and restores grouped view
- Cmd+K keyboard shortcut focuses search input
- Empty search results show "No conversations found" message
</success_criteria>

<output>
After completion, create `.planning/phases/05-sidebar-navigation/05-04-SUMMARY.md`
</output>

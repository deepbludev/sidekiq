---
phase: 11-workspace-authorization
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - sidekiq-webapp/src/app/api/chat/route.ts
  - sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
  - sidekiq-webapp/src/app/(dashboard)/chat/page.tsx
  - sidekiq-webapp/src/features/workspace/hooks/use-active-workspace.ts
autonomous: true

must_haves:
  truths:
    - "Chat route validates workspace membership using validateWorkspaceMembership() on every POST"
    - "Chat route uses x-workspace-id header for new thread creation (not hardcoded personal workspace)"
    - "Chat route verifies existing thread belongs to the request's workspace"
    - "Chat route verifies sidekiq belongs to the request's workspace"
    - "Thread SSR page verifies user is a member of the thread's workspace"
    - "New chat SSR page verifies user is a member of the sidekiq's workspace"
    - "Workspace switch invalidates thread.list and sidekiq.list queries"
  artifacts:
    - path: "sidekiq-webapp/src/app/api/chat/route.ts"
      provides: "Workspace-validated chat endpoint"
      contains: "validateWorkspaceMembership"
    - path: "sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx"
      provides: "Workspace-validated thread SSR page"
      contains: "validateWorkspaceMembership"
    - path: "sidekiq-webapp/src/app/(dashboard)/chat/page.tsx"
      provides: "Workspace-validated new chat SSR page"
      contains: "validateWorkspaceMembership"
    - path: "sidekiq-webapp/src/features/workspace/hooks/use-active-workspace.ts"
      provides: "Query invalidation on workspace switch"
      contains: "invalidate"
  key_links:
    - from: "sidekiq-webapp/src/app/api/chat/route.ts"
      to: "sidekiq-webapp/src/shared/lib/workspace-auth.ts"
      via: "import validateWorkspaceMembership"
      pattern: "import.*validateWorkspaceMembership.*workspace-auth"
    - from: "sidekiq-webapp/src/app/api/chat/route.ts"
      to: "req.headers.get"
      via: "x-workspace-id header read"
      pattern: "req\\.headers\\.get.*x-workspace-id"
    - from: "sidekiq-webapp/src/features/workspace/hooks/use-active-workspace.ts"
      to: "api.useUtils()"
      via: "TanStack Query invalidation on workspace switch"
      pattern: "utils\\.thread\\.list\\.invalidate|utils\\.sidekiq\\.list\\.invalidate"
---

<objective>
Add workspace authorization to the `/api/chat` route handler and SSR pages, and wire query invalidation on workspace switch in the client hook.

Purpose: The chat route is the primary non-tRPC data access path -- it must validate workspace membership independently. SSR pages make direct DB queries that bypass tRPC middleware. Query invalidation ensures stale data is cleared when switching workspaces.

Output: 4 modified files covering all non-tRPC data access paths and client-side cache management.
</objective>

<execution_context>
@/Users/carlocasorzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/carlocasorzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-workspace-authorization/11-CONTEXT.md
@.planning/phases/11-workspace-authorization/11-RESEARCH.md
@.planning/phases/11-workspace-authorization/11-01-SUMMARY.md

Key source files:
@sidekiq-webapp/src/app/api/chat/route.ts
@sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
@sidekiq-webapp/src/app/(dashboard)/chat/page.tsx
@sidekiq-webapp/src/features/workspace/hooks/use-active-workspace.ts
@sidekiq-webapp/src/shared/lib/workspace-auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workspace authorization to chat route handler</name>
  <files>sidekiq-webapp/src/app/api/chat/route.ts</files>
  <action>
Modify the `POST` handler in `src/app/api/chat/route.ts` to add workspace validation using the shared helper.

**Add imports:**
```typescript
import { validateWorkspaceMembership } from "@sidekiq/shared/lib/workspace-auth";
```

**Step 1: Add workspace resolution after session check (after line ~68, before body parsing)**

Insert workspace validation right after the session check:

```typescript
// 1b. Resolve workspace from header
const headerWorkspaceId = req.headers.get("x-workspace-id");
let workspaceId: string;

if (headerWorkspaceId) {
  const membership = await validateWorkspaceMembership(
    db,
    headerWorkspaceId,
    session.user.id,
  );
  if (!membership) {
    console.warn(
      `[Auth] Unauthorized workspace access in chat: userId=${session.user.id}, workspaceId=${headerWorkspaceId}, timestamp=${new Date().toISOString()}`,
    );
    return new Response(
      JSON.stringify({ error: "Access denied" }),
      { status: 403, headers: { "Content-Type": "application/json" } },
    );
  }
  workspaceId = headerWorkspaceId;
} else {
  // Fallback to personal workspace when no header (graceful degradation)
  const personalWs = await db.query.workspaces.findFirst({
    where: and(
      eq(workspaces.ownerId, session.user.id),
      eq(workspaces.type, "personal"),
    ),
    columns: { id: true },
  });
  if (!personalWs) {
    return new Response(
      JSON.stringify({ error: "Personal workspace not found" }),
      { status: 500, headers: { "Content-Type": "application/json" } },
    );
  }
  workspaceId = personalWs.id;
}
```

Note: For the chat route, do NOT use `resolveWorkspaceId()` because we need to return HTTP responses (not throw tRPC errors) and the fallback behavior is slightly different (403 on invalid workspace, not silent fallback). The explicit code gives better control.

**Step 2: Replace sidekiq ownership check (section 2b, ~lines 94-114)**

Replace the existing sidekiq ownership check with workspace membership check:

```typescript
// 2b. Verify sidekiq belongs to active workspace (security check)
if (sidekiqId) {
  const sidekiqRecord = await db.query.sidekiqs.findFirst({
    where: eq(sidekiqs.id, sidekiqId),
    columns: { workspaceId: true },
  });

  if (!sidekiqRecord) {
    return new Response(JSON.stringify({ error: "Sidekiq not found" }), {
      status: 404,
      headers: { "Content-Type": "application/json" },
    });
  }

  if (sidekiqRecord.workspaceId !== workspaceId) {
    return new Response(
      JSON.stringify({ error: "Access denied" }),
      { status: 403, headers: { "Content-Type": "application/json" } },
    );
  }
}
```

**Step 3: Add workspace check to existing thread verification (section 3, ~line 121-149)**

After fetching the existing thread, add workspace match verification:

```typescript
if (threadId) {
  const existingThread = await db.query.threads.findFirst({
    where: eq(threads.id, threadId),
  });

  if (!existingThread) {
    return new Response(JSON.stringify({ error: "Thread not found" }), {
      status: 404,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Verify thread belongs to the active workspace
  if (existingThread.workspaceId !== workspaceId) {
    return new Response(
      JSON.stringify({ error: "Access denied" }),
      { status: 403, headers: { "Content-Type": "application/json" } },
    );
  }

  // Keep userId check for thread creator verification (Phase 11 decision: only creator can send messages in their thread)
  if (existingThread.userId !== session.user.id) {
    return new Response(
      JSON.stringify({ error: "Access denied" }),
      { status: 403, headers: { "Content-Type": "application/json" } },
    );
  }

  // ... rest unchanged (auto-unarchive, etc.)
```

**Step 4: Replace personal workspace lookup for new threads (section 3, ~lines 150-182)**

In the `else` branch (new thread creation), replace the personal workspace lookup with the already-resolved `workspaceId`:

```typescript
} else {
  isNewThread = true;
  const newThreadId = nanoid();

  // Use the workspace from the validated header (or personal workspace fallback)
  const [newThread] = await db
    .insert(threads)
    .values({
      id: newThreadId,
      userId: session.user.id,
      workspaceId, // Use resolved workspaceId instead of hardcoded personal lookup
      title: null,
      activeModel: modelId,
      sidekiqId: sidekiqId ?? null,
      lastActivityAt: new Date(),
    })
    .returning();
  // ... rest unchanged
```

DELETE the entire personal workspace lookup block (the `db.query.workspaces.findFirst(...)` that was there before) -- it's replaced by the workspace resolution at the top of the handler.

**Step 5: Clean up unused import**

If the `workspaces` import from schema is still needed for the personal workspace fallback in step 1, keep it. The existing import already includes `workspaces`. Remove the `isNull` import if no longer needed (it was used in chat/page.tsx, not here -- verify).
  </action>
  <verify>
1. `npx tsc --noEmit` passes -- no type errors
2. Grep for `validateWorkspaceMembership` in `route.ts` confirms import and usage
3. Grep for `x-workspace-id` in `route.ts` confirms header reading
4. Grep for `personalWorkspace` in `route.ts` -- should appear only in the fallback block at the top, NOT in the new thread creation section
5. The personal workspace lookup that was inside the "new thread" block is GONE
  </verify>
  <done>
- Chat route reads `x-workspace-id` header and validates membership
- Invalid workspace returns 403 "Access denied"
- Missing header falls back to personal workspace
- Existing threads are verified to belong to the active workspace
- Sidekiq ownership is verified by workspace membership (not direct ownerId)
- New threads use the resolved workspaceId from the header
- All security paths log unauthorized access attempts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add workspace validation to SSR pages and wire query invalidation</name>
  <files>
    sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
    sidekiq-webapp/src/app/(dashboard)/chat/page.tsx
    sidekiq-webapp/src/features/workspace/hooks/use-active-workspace.ts
  </files>
  <action>
**A. `src/app/(dashboard)/chat/[threadId]/page.tsx` -- Workspace validation for thread page**

Per research recommendation: For SSR pages, infer workspace from the data being accessed (the thread) rather than from a header. Validate that the user is a member of that thread's workspace.

Add import:
```typescript
import { validateWorkspaceMembership } from "@sidekiq/shared/lib/workspace-auth";
```

In the `ThreadPage` function, after fetching the thread (the existing `db.query.threads.findFirst()` call), add a workspace membership check. The thread query currently filters by `eq(threads.userId, session.user.id)` -- this needs to change because in team workspaces, another member might view a thread they didn't create.

**Modify the thread query:**
Change from filtering by userId to a broader query, then validate workspace membership:

```typescript
// Load thread by ID (no userId filter -- workspace membership is the access check)
const thread = await db.query.threads.findFirst({
  where: eq(threads.id, threadId),
  columns: {
    id: true,
    title: true,
    isArchived: true,
    activeModel: true,
    sidekiqId: true,
    workspaceId: true, // Need this for membership check
  },
  with: {
    sidekiq: {
      columns: {
        id: true,
        name: true,
        description: true,
        avatar: true,
        conversationStarters: true,
        defaultModel: true,
      },
    },
  },
});

if (!thread) {
  redirect("/chat");
}

// Verify user is a member of the thread's workspace
const membership = await validateWorkspaceMembership(
  db,
  thread.workspaceId,
  session.user.id,
);

if (!membership) {
  redirect("/chat");
}
```

Do the same in `generateMetadata`:
- Remove the `eq(threads.userId, session.user.id)` filter from the metadata query
- After fetching the thread, validate workspace membership
- If not a member, return generic `{ title: "Sidekiq" }` metadata

**B. `src/app/(dashboard)/chat/page.tsx` -- Workspace validation for new chat page**

Add import:
```typescript
import { validateWorkspaceMembership } from "@sidekiq/shared/lib/workspace-auth";
import { workspaceMembers } from "@sidekiq/shared/db/schema";
```

Replace the existing sidekiq access check (the `or(eq(sidekiqs.ownerId, ...), isNull(sidekiqs.workspaceId))` logic) with workspace membership validation:

```typescript
const sidekiq = sidekiqId
  ? await db.query.sidekiqs.findFirst({
      where: eq(sidekiqs.id, sidekiqId),
      columns: {
        id: true,
        name: true,
        description: true,
        avatar: true,
        conversationStarters: true,
        defaultModel: true,
        workspaceId: true, // Need this for membership check
      },
    })
  : null;

// If sidekiq found, verify user is a member of its workspace
if (sidekiq?.workspaceId) {
  const membership = await validateWorkspaceMembership(
    db,
    sidekiq.workspaceId,
    session.user.id,
  );
  if (!membership) {
    // User is not a member of this sidekiq's workspace -- show new chat without sidekiq
    return <ChatInterface key="no-sidekiq" threadId={null} sidekiq={null} />;
  }
}
```

Remove the `or`, `isNull` imports from `drizzle-orm` if no longer needed (only `eq` should remain).

Remove `workspaceId` from the columns passed to `ChatInterface` (it doesn't need it -- only the display columns).

Make sure the sidekiq object passed to `ChatInterface` does NOT include the `workspaceId` field (either destructure it out or select only the needed columns for the return).

**C. `src/features/workspace/hooks/use-active-workspace.ts` -- Query invalidation on workspace switch**

Add import:
```typescript
import { api } from "@sidekiq/shared/trpc/react";
```

(It's already imported -- verify.)

Inside the `useActiveWorkspace` hook, get the tRPC utils:
```typescript
const utils = api.useUtils();
```

Modify the `setActiveWorkspaceId` callback to invalidate workspace-scoped queries:

```typescript
const setActiveWorkspaceId = useCallback(
  (workspaceId: string | null) => {
    if (workspaceId) {
      localStorage.setItem(ACTIVE_WORKSPACE_KEY, workspaceId);
    } else {
      localStorage.removeItem(ACTIVE_WORKSPACE_KEY);
    }
    setActiveWorkspaceIdState(workspaceId);

    // Invalidate workspace-scoped queries so they refetch with new x-workspace-id header
    void utils.thread.list.invalidate();
    void utils.sidekiq.list.invalidate();
    // Note: workspace.list is intentionally NOT invalidated (it's user-global, not workspace-scoped)
  },
  [utils],
);
```

The `utils` must be added to the dependency array of `useCallback`.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `pnpm build` succeeds (validates server components, client components, imports)
3. Grep for `validateWorkspaceMembership` in `[threadId]/page.tsx` and `chat/page.tsx` confirms usage
4. Grep for `invalidate` in `use-active-workspace.ts` confirms thread.list and sidekiq.list invalidation
5. Grep for `isNull` in `chat/page.tsx` returns 0 matches (removed)
6. Grep for `userId` in `[threadId]/page.tsx` thread query returns 0 matches in the findFirst WHERE clause (replaced by workspace check)
  </verify>
  <done>
- Thread SSR page validates workspace membership by inferring workspace from the thread record
- New chat SSR page validates workspace membership for sidekiq access
- Both pages redirect/degrade gracefully on access denied (no error pages)
- Workspace switch invalidates thread.list and sidekiq.list TanStack queries
- All non-tRPC data access paths are workspace-protected
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero type errors in all 4 modified files
2. `pnpm build` -- full Next.js build passes
3. All non-tRPC data access paths (chat route, thread page, new chat page) use `validateWorkspaceMembership`
4. Chat route reads `x-workspace-id` header and validates/falls back correctly
5. SSR pages infer workspace from the data being accessed
6. Workspace switch triggers query invalidation for workspace-scoped data
7. No hardcoded personal workspace lookup remains in chat route new thread creation
</verification>

<success_criteria>
- Chat route POST handler validates workspace membership before any data access
- Invalid workspace in chat route returns 403
- Missing workspace header in chat route falls back to personal workspace
- New threads are created with the header-provided workspace (not hardcoded personal)
- Existing thread access requires matching workspace
- Sidekiq access in chat route requires matching workspace
- Thread SSR page uses workspace membership (not userId) for access control
- New chat SSR page validates sidekiq workspace membership
- Workspace switch invalidates thread.list and sidekiq.list queries
- Full build passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-workspace-authorization/11-03-SUMMARY.md`
</output>

---
phase: 02-basic-chat-interface
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekiq-webapp/package.json
  - sidekiq-webapp/src/components/chat/message-item.tsx
  - sidekiq-webapp/src/components/chat/message-actions.tsx
  - sidekiq-webapp/src/components/chat/message-content.tsx
  - sidekiq-webapp/src/components/chat/scroll-to-bottom.tsx
autonomous: true

must_haves:
  truths:
    - "AI messages render markdown with headers, bold, italic, lists, tables"
    - "Code blocks have syntax highlighting that matches current theme"
    - "Code blocks show language label and copy button"
    - "Incomplete markdown during streaming displays gracefully without breaking"
    - "Message actions (copy, edit, regenerate) appear on hover"
    - "Copy action copies message content and shows success toast"
    - "Scroll-to-bottom button appears when user scrolls away from bottom"
  artifacts:
    - path: "sidekiq-webapp/src/components/chat/message-content.tsx"
      provides: "Streamdown-based markdown renderer"
      exports: ["MessageContent"]
    - path: "sidekiq-webapp/src/components/chat/message-actions.tsx"
      provides: "Hover actions for copy/edit/regenerate"
      exports: ["MessageActions"]
    - path: "sidekiq-webapp/src/components/chat/scroll-to-bottom.tsx"
      provides: "Floating scroll button"
      exports: ["ScrollToBottom"]
  key_links:
    - from: "sidekiq-webapp/src/components/chat/message-item.tsx"
      to: "sidekiq-webapp/src/components/chat/message-content.tsx"
      via: "renders MessageContent for assistant messages"
      pattern: "<MessageContent"
    - from: "sidekiq-webapp/src/components/chat/message-item.tsx"
      to: "sidekiq-webapp/src/components/chat/message-actions.tsx"
      via: "renders MessageActions with hover visibility"
      pattern: "<MessageActions"
---

<objective>
Implement markdown rendering with syntax highlighting and message interaction features.

Purpose: Enhance the chat experience with properly rendered AI responses including code blocks, and provide message actions that users expect from a premium chat application. The scroll-to-bottom button improves navigation in long conversations.

Output:
- MessageContent component using Streamdown for streaming markdown
- MessageActions component with copy/edit/regenerate buttons
- ScrollToBottom floating button
- Updated MessageItem with new minimal lines style (per CONTEXT.md)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-chat-interface/02-RESEARCH.md
@.planning/phases/02-basic-chat-interface/02-CONTEXT.md
@sidekiq-webapp/src/components/chat/message-item.tsx
@sidekiq-webapp/src/components/chat/chat-interface.tsx
@sidekiq-webapp/src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Streamdown for markdown rendering</name>
  <files>
    sidekiq-webapp/package.json
  </files>
  <action>
Install Streamdown and its code plugin for syntax highlighting:
```bash
cd sidekiq-webapp && pnpm add streamdown @streamdown/code
```

Streamdown is Vercel's streaming markdown library designed for AI chat applications. It handles incomplete markdown gracefully during streaming, unlike react-markdown.

The `@streamdown/code` plugin uses Shiki for syntax highlighting with dual theme support.
  </action>
  <verify>
Package.json includes `streamdown` and `@streamdown/code`.
Run `pnpm typecheck` passes.
  </verify>
  <done>Streamdown and code plugin installed</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageContent component with Streamdown</name>
  <files>
    sidekiq-webapp/src/components/chat/message-content.tsx
  </files>
  <action>
Create `src/components/chat/message-content.tsx`:

```typescript
'use client';

import { Streamdown } from 'streamdown';
import { createCodePlugin } from '@streamdown/code';
import { useMemo } from 'react';

import { cn } from '@sidekiq/lib/utils';

interface MessageContentProps {
  /** The markdown content to render */
  content: string;
  /** Whether the content is currently streaming (enables animation) */
  isStreaming?: boolean;
  /** Additional CSS classes */
  className?: string;
}

/**
 * Renders markdown content with streaming support and syntax highlighting.
 * Uses Streamdown for graceful handling of incomplete markdown during streaming.
 * Code blocks use Shiki with dual themes for light/dark mode support.
 */
export function MessageContent({
  content,
  isStreaming = false,
  className,
}: MessageContentProps) {
  // Memoize code plugin to avoid recreating on every render
  const codePlugin = useMemo(
    () =>
      createCodePlugin({
        themes: ['github-light', 'github-dark'],
      }),
    []
  );

  return (
    <Streamdown
      plugins={{ code: codePlugin }}
      isAnimating={isStreaming}
      className={cn(
        // Base prose styling
        'prose prose-sm max-w-none',
        // Dark mode prose
        'dark:prose-invert',
        // Customize prose colors to match our theme
        'prose-headings:text-foreground',
        'prose-p:text-foreground/90',
        'prose-strong:text-foreground',
        'prose-code:text-foreground',
        'prose-pre:bg-muted/50 prose-pre:border prose-pre:border-border',
        // Links
        'prose-a:text-primary prose-a:no-underline hover:prose-a:underline',
        // Lists
        'prose-li:text-foreground/90',
        // Code blocks
        '[&_pre]:rounded-lg [&_pre]:my-3',
        // Code inline
        'prose-code:before:content-none prose-code:after:content-none',
        'prose-code:bg-muted/50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded',
        className
      )}
    >
      {content}
    </Streamdown>
  );
}
```

Note: The code plugin automatically handles the language label display. Streamdown provides a copy button on code blocks by default (appears on hover). This is controlled via the `controls={{ code: true }}` prop which is enabled by default - no additional configuration needed. The button is automatically disabled during streaming to prevent copying incomplete code.
  </action>
  <verify>
File exists at specified path.
`pnpm typecheck` passes.
Component renders markdown correctly in isolation.
  </verify>
  <done>MessageContent component created with Streamdown and dual-theme code highlighting</done>
</task>

<task type="auto">
  <name>Task 3: Create MessageActions component</name>
  <files>
    sidekiq-webapp/src/components/chat/message-actions.tsx
  </files>
  <action>
**Prerequisite check:** Verify Tooltip component exists at `src/components/ui/tooltip.tsx`. If not, install via:
```bash
cd sidekiq-webapp && npx shadcn@latest add tooltip
```

Create `src/components/chat/message-actions.tsx`:

```typescript
'use client';

import { Copy, Pencil, RefreshCw, Check } from 'lucide-react';
import { useState } from 'react';
import { toast } from 'sonner';

import { Button } from '@sidekiq/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@sidekiq/components/ui/tooltip';
import { cn } from '@sidekiq/lib/utils';

interface MessageActionsProps {
  /** The role of the message (user or assistant) */
  role: 'user' | 'assistant';
  /** The text content to copy */
  content: string;
  /** Callback when user clicks edit (user messages only) */
  onEdit?: () => void;
  /** Callback when user clicks regenerate (assistant messages only) */
  onRegenerate?: () => void;
  /** Additional CSS classes */
  className?: string;
}

/**
 * Message action buttons that appear on hover.
 * - Copy: Available for all messages
 * - Edit: Available for user messages only
 * - Regenerate: Available for assistant messages only
 */
export function MessageActions({
  role,
  content,
  onEdit,
  onRegenerate,
  className,
}: MessageActionsProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setCopied(true);
      toast.success('Copied to clipboard');

      // Reset copied state after 2 seconds
      setTimeout(() => setCopied(false), 2000);
    } catch {
      toast.error('Failed to copy to clipboard');
    }
  };

  return (
    <div
      className={cn(
        'flex items-center gap-0.5',
        'opacity-0 group-hover:opacity-100',
        'transition-opacity duration-200',
        className
      )}
    >
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="ghost"
            size="icon-sm"
            onClick={handleCopy}
            className="h-7 w-7 text-muted-foreground hover:text-foreground"
          >
            {copied ? (
              <Check className="h-3.5 w-3.5 text-green-500" />
            ) : (
              <Copy className="h-3.5 w-3.5" />
            )}
          </Button>
        </TooltipTrigger>
        <TooltipContent side="bottom">
          <p>{copied ? 'Copied!' : 'Copy'}</p>
        </TooltipContent>
      </Tooltip>

      {role === 'user' && onEdit && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="ghost"
              size="icon-sm"
              onClick={onEdit}
              className="h-7 w-7 text-muted-foreground hover:text-foreground"
            >
              <Pencil className="h-3.5 w-3.5" />
            </Button>
          </TooltipTrigger>
          <TooltipContent side="bottom">
            <p>Edit</p>
          </TooltipContent>
        </Tooltip>
      )}

      {role === 'assistant' && onRegenerate && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="ghost"
              size="icon-sm"
              onClick={onRegenerate}
              className="h-7 w-7 text-muted-foreground hover:text-foreground"
            >
              <RefreshCw className="h-3.5 w-3.5" />
            </Button>
          </TooltipTrigger>
          <TooltipContent side="bottom">
            <p>Regenerate</p>
          </TooltipContent>
        </Tooltip>
      )}
    </div>
  );
}
```
  </action>
  <verify>
File exists at specified path.
`pnpm typecheck` passes.
All button variants and icon imports resolve.
  </verify>
  <done>MessageActions component created with copy, edit, and regenerate actions</done>
</task>

<task type="auto">
  <name>Task 4: Create ScrollToBottom floating button</name>
  <files>
    sidekiq-webapp/src/components/chat/scroll-to-bottom.tsx
  </files>
  <action>
Create `src/components/chat/scroll-to-bottom.tsx`:

```typescript
'use client';

import { ArrowDown } from 'lucide-react';
import { useEffect, useState, type RefObject } from 'react';

import { Button } from '@sidekiq/components/ui/button';
import { cn } from '@sidekiq/lib/utils';

interface ScrollToBottomProps {
  /** Reference to the scroll container */
  scrollContainer: RefObject<HTMLDivElement | null>;
  /** Threshold in pixels from bottom to show button */
  threshold?: number;
  /** Additional CSS classes */
  className?: string;
}

/**
 * Floating button that appears when user scrolls away from the bottom.
 * Clicking scrolls smoothly to the bottom of the container.
 */
export function ScrollToBottom({
  scrollContainer,
  threshold = 200,
  className,
}: ScrollToBottomProps) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const container = scrollContainer.current;
    if (!container) return;

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
      setIsVisible(distanceFromBottom > threshold);
    };

    // Initial check
    handleScroll();

    container.addEventListener('scroll', handleScroll, { passive: true });
    return () => container.removeEventListener('scroll', handleScroll);
  }, [scrollContainer, threshold]);

  const scrollToBottom = () => {
    const container = scrollContainer.current;
    if (!container) return;

    container.scrollTo({
      top: container.scrollHeight,
      behavior: 'smooth',
    });
  };

  if (!isVisible) return null;

  return (
    <Button
      variant="outline"
      size="icon"
      onClick={scrollToBottom}
      className={cn(
        'fixed bottom-24 right-8 z-10',
        'rounded-full shadow-lg',
        'glass border-border/50',
        'hover:scale-105 transition-transform',
        className
      )}
      aria-label="Scroll to bottom"
    >
      <ArrowDown className="h-4 w-4" />
    </Button>
  );
}
```
  </action>
  <verify>
File exists at specified path.
`pnpm typecheck` passes.
Button component imports resolve.
  </verify>
  <done>ScrollToBottom floating button created with visibility tracking</done>
</task>

<task type="auto">
  <name>Task 5: Update MessageItem with minimal lines style and new components</name>
  <files>
    sidekiq-webapp/src/components/chat/message-item.tsx
  </files>
  <action>
Replace the existing `src/components/chat/message-item.tsx` with the new minimal lines style:

```typescript
'use client';

import type { UIMessage } from 'ai';
import { useState } from 'react';

import { MessageContent } from './message-content';
import { MessageActions } from './message-actions';
import { cn } from '@sidekiq/lib/utils';

interface MessageItemProps {
  /** The message to render */
  message: UIMessage;
  /** Whether this message is currently streaming */
  isStreaming?: boolean;
  /** Callback when user clicks edit */
  onEdit?: () => void;
  /** Callback when user clicks regenerate */
  onRegenerate?: () => void;
}

/**
 * Extracts text content from a UIMessage's parts.
 */
function extractTextContent(message: UIMessage): string {
  return message.parts
    .filter(
      (part): part is { type: 'text'; text: string } => part.type === 'text'
    )
    .map((part) => part.text)
    .join('');
}

/**
 * Formats a timestamp for display.
 */
function formatTime(date: Date): string {
  return new Intl.DateTimeFormat('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  }).format(date);
}

/**
 * Renders a single chat message with minimal lines style.
 *
 * Per CONTEXT.md:
 * - No bubbles/cards, just text with subtle background tint
 * - Timestamps shown on hover only
 * - Narrow centered content area (~700px max)
 * - Actions appear inline at end of message on hover
 */
export function MessageItem({
  message,
  isStreaming = false,
  onEdit,
  onRegenerate,
}: MessageItemProps) {
  const [showTimestamp, setShowTimestamp] = useState(false);
  const isUser = message.role === 'user';
  const content = extractTextContent(message);

  return (
    <div
      className={cn(
        'group relative py-4 px-4 -mx-4',
        // Subtle background tint to distinguish user vs AI
        isUser
          ? 'bg-transparent'
          : 'bg-muted/30 dark:bg-muted/10'
      )}
      onMouseEnter={() => setShowTimestamp(true)}
      onMouseLeave={() => setShowTimestamp(false)}
    >
      <div className="mx-auto max-w-[700px]">
        <div className="flex items-start justify-between gap-4">
          {/* Message content */}
          <div className="min-w-0 flex-1">
            {isUser ? (
              // User messages: plain text
              <p className="text-sm leading-relaxed whitespace-pre-wrap text-foreground">
                {content}
              </p>
            ) : (
              // Assistant messages: rendered markdown
              <MessageContent
                content={content}
                isStreaming={isStreaming}
              />
            )}
          </div>

          {/* Actions (visible on hover) */}
          <MessageActions
            role={message.role as 'user' | 'assistant'}
            content={content}
            onEdit={isUser ? onEdit : undefined}
            onRegenerate={!isUser ? onRegenerate : undefined}
          />
        </div>

        {/* Timestamp (visible on hover) */}
        {showTimestamp && message.createdAt && (
          <time className="mt-1.5 block text-xs text-muted-foreground">
            {formatTime(new Date(message.createdAt))}
          </time>
        )}
      </div>
    </div>
  );
}
```

This replaces the bubble/avatar style with the minimal lines style specified in CONTEXT.md.
  </action>
  <verify>
File updated with new implementation.
`pnpm typecheck` passes.
No avatar/bubble styling remains.
MessageContent and MessageActions imported and used.
  </verify>
  <done>MessageItem updated with minimal lines style, markdown rendering, and hover actions</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm check` passes
3. AI messages render markdown (test with headers, bold, code blocks)
4. Code blocks show syntax highlighting
5. Code theme changes with app theme (light code in light mode)
6. Copy button works and shows success toast
7. Actions visible on message hover
8. Timestamps visible on message hover
9. ScrollToBottom button appears when scrolled up
</verification>

<success_criteria>
- Streamdown renders AI markdown responses correctly during streaming
- Code blocks have syntax highlighting with dual theme support
- Copy action copies content and shows toast feedback
- Edit action visible on user messages (callback passed through)
- Regenerate action visible on AI messages (callback passed through)
- MessageItem uses minimal lines style (no bubbles/avatars)
- Timestamps appear on hover
- ScrollToBottom button functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-chat-interface/02-02-SUMMARY.md`
</output>

---
phase: 02-basic-chat-interface
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - sidekiq-webapp/src/components/chat/empty-state.tsx
  - sidekiq-webapp/src/components/chat/chat-interface.tsx
  - sidekiq-webapp/src/components/chat/chat-input.tsx
  - sidekiq-webapp/src/components/chat/message-list.tsx
  - sidekiq-webapp/src/app/(dashboard)/chat/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Empty state shows 'Start your first conversation' CTA"
    - "Empty state displays categorized suggestion prompts"
    - "Clicking a prompt fills the ChatInput textarea with the selected prompt text"
    - "User sees their message instantly when sent (optimistic UI from useChat)"
    - "Failed messages show error toast at bottom-center and trigger rollback"
    - "Chat interface has glassmorphism styling"
    - "Theme toggle is accessible in the chat header"
  artifacts:
    - path: "sidekiq-webapp/src/components/chat/empty-state.tsx"
      provides: "Categorized prompt suggestions"
      exports: ["EmptyState"]
    - path: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      provides: "Updated chat container with glass styling and error handling"
      exports: ["ChatInterface"]
  key_links:
    - from: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      to: "sidekiq-webapp/src/components/chat/empty-state.tsx"
      via: "renders EmptyState when no messages"
      pattern: "<EmptyState"
    - from: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      to: "sonner"
      via: "toast.error on message failure"
      pattern: "toast\\.error"
---

<objective>
Complete the chat interface with empty state, glassmorphism styling, and proper error handling.

Purpose: Deliver the final user experience for Phase 2 by integrating all components into a cohesive interface. The empty state guides new users with actionable prompts, glassmorphism creates the premium aesthetic, and error handling ensures graceful failure.

Output:
- EmptyState component with categorized prompts
- Updated ChatInterface with glass styling and error toasts
- Updated ChatInput with glass styling
- Chat layout header with ThemeToggle
- MessageList with EmptyState integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-chat-interface/02-RESEARCH.md
@.planning/phases/02-basic-chat-interface/02-CONTEXT.md
@.planning/phases/02-basic-chat-interface/02-01-PLAN.md
@.planning/phases/02-basic-chat-interface/02-02-PLAN.md
@sidekiq-webapp/src/components/chat/chat-interface.tsx
@sidekiq-webapp/src/components/chat/chat-input.tsx
@sidekiq-webapp/src/components/chat/message-list.tsx
@sidekiq-webapp/src/app/(dashboard)/chat/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmptyState component with categorized prompts</name>
  <files>
    sidekiq-webapp/src/components/chat/empty-state.tsx
  </files>
  <action>
Create `src/components/chat/empty-state.tsx`:

```typescript
'use client';

import { Sparkles, Code, Search, FileText } from 'lucide-react';
import type { LucideIcon } from 'lucide-react';

import { cn } from '@sidekiq/lib/utils';

interface PromptCategory {
  name: string;
  icon: LucideIcon;
  prompts: string[];
}

const PROMPT_CATEGORIES: PromptCategory[] = [
  {
    name: 'Creative',
    icon: Sparkles,
    prompts: [
      'Write a short story about a time traveler',
      'Help me brainstorm names for my startup',
      'Create a haiku about technology',
    ],
  },
  {
    name: 'Coding',
    icon: Code,
    prompts: [
      'Explain async/await in JavaScript',
      'Write a React hook for local storage',
      'Help me debug this error message',
    ],
  },
  {
    name: 'Research',
    icon: Search,
    prompts: [
      'Compare REST vs GraphQL APIs',
      'What are the benefits of TypeScript?',
      'Explain the CAP theorem simply',
    ],
  },
  {
    name: 'Writing',
    icon: FileText,
    prompts: [
      'Help me write a professional email',
      'Summarize this article for me',
      'Proofread and improve this text',
    ],
  },
];

interface EmptyStateProps {
  /** Callback when user selects a prompt suggestion */
  onPromptSelect: (prompt: string) => void;
}

/**
 * Empty state shown when chat has no messages.
 * Displays categorized prompt suggestions to help users get started.
 */
export function EmptyState({ onPromptSelect }: EmptyStateProps) {
  return (
    <div className="flex h-full flex-col items-center justify-center p-8">
      {/* Welcome message */}
      <div className="mb-8 text-center">
        <h2 className="text-2xl font-semibold text-foreground">
          Start your first conversation
        </h2>
        <p className="mt-2 text-muted-foreground">
          Choose a prompt below or type your own message
        </p>
      </div>

      {/* Categorized prompts */}
      <div className="grid w-full max-w-3xl grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-4">
        {PROMPT_CATEGORIES.map((category) => (
          <div key={category.name} className="space-y-3">
            {/* Category header */}
            <div className="flex items-center gap-2">
              <category.icon className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm font-medium text-foreground">
                {category.name}
              </span>
            </div>

            {/* Prompt buttons */}
            <div className="space-y-2">
              {category.prompts.map((prompt) => (
                <button
                  key={prompt}
                  onClick={() => onPromptSelect(prompt)}
                  className={cn(
                    'w-full rounded-lg p-3 text-left text-sm',
                    'glass-subtle',
                    'text-foreground/80 hover:text-foreground',
                    'hover:bg-white/60 dark:hover:bg-zinc-800/60',
                    'transition-colors duration-200',
                    'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring'
                  )}
                >
                  {prompt}
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```
  </action>
  <verify>
File exists at specified path.
`pnpm typecheck` passes.
Component renders 4 categories with 3 prompts each.
  </verify>
  <done>EmptyState component created with categorized prompts and glass styling</done>
</task>

<task type="auto">
  <name>Task 2: Update ChatInput with glassmorphism styling</name>
  <files>
    sidekiq-webapp/src/components/chat/chat-input.tsx
  </files>
  <action>
Update `src/components/chat/chat-input.tsx` to add glassmorphism styling:

```typescript
'use client';

import type { FormEvent, KeyboardEvent } from 'react';
import { Send, Square } from 'lucide-react';

import { Button } from '@sidekiq/components/ui/button';
import { Textarea } from '@sidekiq/components/ui/textarea';
import { cn } from '@sidekiq/lib/utils';

interface ChatInputProps {
  /** Current input value */
  input: string;
  /** Function to update input value */
  setInput: (value: string) => void;
  /** Function to handle form submission */
  onSubmit: (e: FormEvent<HTMLFormElement>) => void;
  /** Whether the AI is currently streaming a response */
  isStreaming: boolean;
  /** Function to stop the current stream */
  onStop: () => void;
  /** Placeholder text */
  placeholder?: string;
}

/**
 * Chat input component with glassmorphism styling.
 *
 * Features:
 * - Auto-resizing textarea
 * - Enter to send, Shift+Enter for newline
 * - Send button disabled when empty or streaming
 * - Stop button appears during streaming
 */
export function ChatInput({
  input,
  setInput,
  onSubmit,
  isStreaming,
  onStop,
  placeholder = 'Type a message...',
}: ChatInputProps) {
  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Enter to send, Shift+Enter for newline
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (input.trim() && !isStreaming) {
        const form = e.currentTarget.form;
        if (form) {
          form.requestSubmit();
        }
      }
    }
  };

  const canSend = input.trim().length > 0 && !isStreaming;

  return (
    <form onSubmit={onSubmit} className="relative">
      <Textarea
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        disabled={isStreaming}
        className={cn(
          'max-h-[200px] min-h-[52px] resize-none pr-24',
          // Glassmorphism input styling
          'glass-input',
          'focus-visible:ring-primary/20',
          'placeholder:text-muted-foreground/60'
        )}
        rows={1}
      />

      <div className="absolute bottom-2 right-2 flex gap-1">
        {isStreaming ? (
          <Button
            type="button"
            variant="destructive"
            size="icon-sm"
            onClick={onStop}
            aria-label="Stop generating"
            className="shadow-sm"
          >
            <Square className="h-4 w-4" />
          </Button>
        ) : (
          <Button
            type="submit"
            size="icon-sm"
            disabled={!canSend}
            aria-label="Send message"
            className="shadow-sm"
          >
            <Send className="h-4 w-4" />
          </Button>
        )}
      </div>
    </form>
  );
}
```
  </action>
  <verify>
File updated with glass-input class.
`pnpm typecheck` passes.
  </verify>
  <done>ChatInput updated with glassmorphism styling</done>
</task>

<task type="auto">
  <name>Task 3: Update MessageList to use EmptyState</name>
  <files>
    sidekiq-webapp/src/components/chat/message-list.tsx
  </files>
  <action>
Update `src/components/chat/message-list.tsx` to render EmptyState:

```typescript
'use client';

import type { UIMessage } from 'ai';

import { MessageItem } from './message-item';
import { EmptyState } from './empty-state';

interface MessageListProps {
  /** Array of messages to render */
  messages: UIMessage[];
  /** ID of the message currently streaming (if any) */
  streamingMessageId?: string;
  /** Callback when user selects a prompt from empty state */
  onPromptSelect?: (prompt: string) => void;
  /** Callback when user clicks edit on a message */
  onEditMessage?: (messageId: string) => void;
  /** Callback when user clicks regenerate on a message */
  onRegenerateMessage?: (messageId: string) => void;
}

/**
 * Renders a list of chat messages with empty state.
 */
export function MessageList({
  messages,
  streamingMessageId,
  onPromptSelect,
  onEditMessage,
  onRegenerateMessage,
}: MessageListProps) {
  if (messages.length === 0) {
    return onPromptSelect ? (
      <EmptyState onPromptSelect={onPromptSelect} />
    ) : (
      // Fallback if no onPromptSelect provided
      <div className="flex h-full items-center justify-center py-12">
        <div className="text-center">
          <h3 className="text-lg font-medium text-foreground">
            Start a conversation
          </h3>
          <p className="mt-1 text-sm text-muted-foreground">
            Type a message below to begin chatting.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="divide-y divide-border/50">
      {messages.map((message) => (
        <MessageItem
          key={message.id}
          message={message}
          isStreaming={message.id === streamingMessageId}
          onEdit={
            onEditMessage ? () => onEditMessage(message.id) : undefined
          }
          onRegenerate={
            onRegenerateMessage
              ? () => onRegenerateMessage(message.id)
              : undefined
          }
        />
      ))}
    </div>
  );
}
```

Note: Added divide-y for subtle separating lines between messages per CONTEXT.md.
  </action>
  <verify>
File updated with EmptyState integration.
`pnpm typecheck` passes.
  </verify>
  <done>MessageList updated with EmptyState and message callbacks</done>
</task>

<task type="auto">
  <name>Task 4: Update ChatInterface with error handling and glassmorphism</name>
  <files>
    sidekiq-webapp/src/components/chat/chat-interface.tsx
  </files>
  <action>
Update `src/components/chat/chat-interface.tsx`:

```typescript
'use client';

import { useRef, useState, type FormEvent } from 'react';
import type { UIMessage } from 'ai';
import { DefaultChatTransport } from 'ai';
import { useChat } from '@ai-sdk/react';
import { toast } from 'sonner';

import { MessageList } from './message-list';
import { ChatInput } from './chat-input';
import { TypingIndicator } from './typing-indicator';
import { ChatScrollAnchor } from './chat-scroll-anchor';
import { ScrollToBottom } from './scroll-to-bottom';
import { cn } from '@sidekiq/lib/utils';

interface ChatInterfaceProps {
  /** Thread ID for message persistence */
  threadId: string;
  /** Initial messages to load from database (Phase 3) */
  initialMessages?: UIMessage[];
}

/**
 * Main chat interface component with glassmorphism styling.
 *
 * Integrates useChat hook with message list, input, typing indicator,
 * and auto-scroll functionality. Includes error handling with toast notifications.
 *
 * Uses AI SDK v6 with DefaultChatTransport for HTTP communication.
 */
export function ChatInterface({
  threadId,
  initialMessages = [],
}: ChatInterfaceProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const [input, setInput] = useState('');

  // Create transport with threadId in body
  const transport = new DefaultChatTransport({
    api: '/api/chat',
    body: { threadId },
  });

  const { messages, sendMessage, status, stop, error } = useChat({
    transport,
    messages: initialMessages,
    onError: (err) => {
      // Error toast at bottom-center (near input)
      toast.error('Failed to send message', {
        description: err.message || 'Please check your connection and try again',
        duration: 5000,
      });
    },
  });

  const isStreaming = status === 'streaming' || status === 'submitted';

  // Get the ID of the currently streaming message
  const streamingMessageId = isStreaming
    ? messages[messages.length - 1]?.id
    : undefined;

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const trimmedInput = input.trim();
    if (!trimmedInput || isStreaming) return;

    setInput('');
    await sendMessage({ text: trimmedInput });
  };

  const handlePromptSelect = (prompt: string) => {
    setInput(prompt);
    // Focus the textarea using a more robust approach
    // setTimeout ensures state update completes before focus
    setTimeout(() => {
      const textarea = scrollContainerRef.current
        ?.closest('.flex.h-full')
        ?.querySelector('textarea');
      textarea?.focus();
    }, 0);
  };

  // Placeholder callbacks for edit/regenerate (full implementation in later phase)
  const handleEditMessage = (messageId: string) => {
    // TODO: Implement edit functionality
    toast.info('Edit coming soon', {
      description: 'Message editing will be available in a future update',
    });
    console.log('Edit message:', messageId);
  };

  const handleRegenerateMessage = (messageId: string) => {
    // TODO: Implement regenerate functionality
    toast.info('Regenerate coming soon', {
      description: 'Response regeneration will be available in a future update',
    });
    console.log('Regenerate message:', messageId);
  };

  return (
    <div className="relative flex h-full flex-col">
      {/* Message area */}
      <div
        ref={scrollContainerRef}
        className={cn(
          'flex-1 overflow-y-auto',
          // Subtle gradient background
          'bg-gradient-to-b from-background to-muted/20'
        )}
      >
        <div className="mx-auto max-w-3xl px-4 py-4">
          <MessageList
            messages={messages}
            streamingMessageId={
              isStreaming && messages[messages.length - 1]?.role === 'assistant'
                ? streamingMessageId
                : undefined
            }
            onPromptSelect={handlePromptSelect}
            onEditMessage={handleEditMessage}
            onRegenerateMessage={handleRegenerateMessage}
          />

          {/* Typing indicator */}
          {isStreaming && messages[messages.length - 1]?.role === 'user' && (
            <TypingIndicator />
          )}

          <ChatScrollAnchor
            isStreaming={isStreaming}
            messagesLength={messages.length}
            scrollContainer={scrollContainerRef}
          />
        </div>
      </div>

      {/* Scroll to bottom button */}
      <ScrollToBottom scrollContainer={scrollContainerRef} />

      {/* Input area with glass effect */}
      <div
        className={cn(
          'border-t px-4 py-4',
          'glass',
          'border-border/50'
        )}
      >
        <div className="mx-auto max-w-3xl">
          {error && (
            <div className="mb-2 rounded-md bg-destructive/10 px-3 py-2 text-sm text-destructive">
              {error.message || 'An error occurred'}
            </div>
          )}
          <ChatInput
            input={input}
            setInput={setInput}
            onSubmit={handleSubmit}
            isStreaming={isStreaming}
            onStop={stop}
          />
        </div>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
File updated with glass styling and error handling.
`pnpm typecheck` passes.
toast.error imported and used in onError.
  </verify>
  <done>ChatInterface updated with glassmorphism, error toasts, and component integration</done>
</task>

<task type="auto">
  <name>Task 5: Update chat layout with header and ThemeToggle</name>
  <files>
    sidekiq-webapp/src/app/(dashboard)/chat/layout.tsx
  </files>
  <action>
Update `src/app/(dashboard)/chat/layout.tsx` to add a header with ThemeToggle:

```typescript
import { TooltipProvider } from '@sidekiq/components/ui/tooltip';
import { ThemeToggle } from '@sidekiq/components/theme/theme-toggle';

/**
 * Chat layout with header containing theme toggle.
 * Sidebar will be added in Phase 5.
 */
export default function ChatLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <TooltipProvider>
      <div className="flex h-screen flex-col">
        {/* Header */}
        <header className="flex h-14 shrink-0 items-center justify-between border-b border-border/50 px-4">
          <div className="flex items-center gap-2">
            {/* Logo/brand - placeholder for now */}
            <span className="text-lg font-semibold">Sidekiq</span>
          </div>

          <div className="flex items-center gap-2">
            <ThemeToggle />
          </div>
        </header>

        {/* Main content */}
        <main className="flex-1 overflow-hidden">
          {children}
        </main>
      </div>
    </TooltipProvider>
  );
}
```

Note: TooltipProvider wraps the layout to enable tooltips for MessageActions.
  </action>
  <verify>
File updated with header and ThemeToggle.
`pnpm typecheck` passes.
ThemeToggle renders in header.
  </verify>
  <done>Chat layout updated with header containing ThemeToggle</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 chat interface with:
1. Theme toggle (Light/Dark/System) in header
2. Glassmorphism styling throughout
3. Markdown rendering with syntax-highlighted code blocks
4. Message actions (copy with feedback, edit/regenerate placeholders)
5. Empty state with categorized prompt suggestions
6. Error handling with toast notifications
7. Scroll-to-bottom floating button
8. Minimal lines message style (no bubbles)
  </what-built>
  <how-to-verify>
Prerequisites:
- Set AI_GATEWAY_API_KEY in .env.local
- Run `pnpm dev` in sidekiq-webapp directory

Test flow:
1. Navigate to http://localhost:3000/chat
2. Verify: Empty state shows "Start your first conversation" with categorized prompts
3. Click a prompt suggestion:
   - Verify the ChatInput textarea is filled with the exact prompt text
   - Verify the textarea receives focus
   - Verify you can immediately type additional text after the prompt
4. Test theme toggle in header:
   - Click Light icon - page turns light
   - Click Dark icon - page turns dark
   - Click System icon - follows OS preference
   - Refresh page - theme persists
5. Send a message asking for code: "Write a TypeScript function to debounce"
6. **CRITICAL - Optimistic UI verification:**
   - Verify: Your message appears IMMEDIATELY in the message list (before AI responds)
   - Verify: Message does NOT flash or disappear while waiting for AI
   - Verify: Input is cleared immediately after sending
7. Verify: AI response shows markdown with syntax-highlighted code
8. Verify: Code block has copy button
9. Hover over messages:
   - User message shows copy + edit icons
   - AI message shows copy + regenerate icons
10. Click copy - verify toast shows "Copied to clipboard"
11. Scroll up during a long response - verify scroll-to-bottom button appears
12. Click scroll-to-bottom - verify smooth scroll
13. **Error handling and rollback verification:**
    - Disconnect network or stop dev server temporarily
    - Try to send a message
    - Verify: Error toast appears at bottom-center
    - Verify: The failed user message is either removed or marked as failed (rollback behavior from useChat)

Visual checks:
- Input area has glassmorphism effect (translucent)
- Subtle gradient background in message area
- Thin, auto-hiding scrollbars
- No message bubbles/avatars - minimal lines style
- Timestamps appear on hover
  </how-to-verify>
  <resume-signal>Type "approved" if Phase 2 is complete, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm check` passes
3. Theme toggle works (Light/Dark/System)
4. Theme persists after refresh
5. No flash of wrong theme on load
6. Empty state shows categorized prompts
7. Prompt selection fills input
8. Glassmorphism styling visible on input area
9. Markdown renders correctly in AI responses
10. Code blocks have syntax highlighting matching theme
11. Message actions appear on hover
12. Copy action shows success toast
13. Error toast appears at bottom-center on failure
14. Scroll-to-bottom button works
</verification>

<success_criteria>
- User sees empty state with CTA when no messages exist
- Categorized prompts help users get started
- Theme toggle in header works for all three modes
- Glassmorphism aesthetic visible (translucent input, subtle glass effects)
- AI responses render full markdown including code with highlighting
- Message actions work (copy confirmed, edit/regenerate show "coming soon")
- Failed messages trigger error toast at bottom-center
- Scroll-to-bottom button appears when scrolled away
- All styling consistent between light and dark modes
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-chat-interface/02-03-SUMMARY.md`
</output>

---
phase: 06-sidekiq-crud
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekiq-webapp/package.json
  - sidekiq-webapp/src/lib/utils/avatar.ts
  - sidekiq-webapp/src/hooks/use-sidekiq-actions.ts
  - sidekiq-webapp/src/hooks/use-view-preference.ts
autonomous: true

must_haves:
  truths:
    - "Avatar color is deterministically generated from name"
    - "Initials are correctly extracted from names (first 2 chars or first letters of first 2 words)"
    - "Sidekiq mutations have optimistic update hooks"
    - "View preference (grid/list) persists across page refreshes"
  artifacts:
    - path: "sidekiq-webapp/src/lib/utils/avatar.ts"
      provides: "Avatar color generation and initials extraction"
      exports: ["generateColorFromName", "getInitials", "AVATAR_COLORS"]
    - path: "sidekiq-webapp/src/hooks/use-sidekiq-actions.ts"
      provides: "Sidekiq mutation hooks with optimistic updates"
      exports: ["useSidekiqActions"]
    - path: "sidekiq-webapp/src/hooks/use-view-preference.ts"
      provides: "Persisted view preference state"
      exports: ["useViewPreference"]
  key_links:
    - from: "sidekiq-webapp/src/hooks/use-sidekiq-actions.ts"
      to: "sidekiq-webapp/src/trpc/react.tsx"
      via: "tRPC mutation hooks"
      pattern: "api\\.sidekiq\\."
---

<objective>
Install dependencies and create utility functions for avatar generation and mutation hooks.

Purpose: Provides reusable utilities needed by multiple Sidekiq components - avatar system, optimistic updates, and view preferences.
Output: Avatar utils, mutation hook with optimistic updates, view preference hook with localStorage persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-sidekiq-crud/06-CONTEXT.md
@.planning/phases/06-sidekiq-crud/06-RESEARCH.md

# Existing patterns to follow
@sidekiq-webapp/src/hooks/use-thread-actions.ts
@sidekiq-webapp/src/hooks/use-sidebar-state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Phase 6 dependencies</name>
  <files>sidekiq-webapp/package.json</files>
  <action>
Install the new dependencies required for Phase 6:

```bash
cd sidekiq-webapp && pnpm add @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @uiw/react-md-editor
```

Also install shadcn/ui breadcrumb component:
```bash
cd sidekiq-webapp && pnpm dlx shadcn@latest add breadcrumb -y
```

Note: frimousse (emoji picker) will be added in Plan 06 when implementing the avatar system.
Note: @trpc-limiter/memory was already added in Plan 01.
  </action>
  <verify>
Check package.json includes:
- @dnd-kit/core
- @dnd-kit/sortable
- @dnd-kit/utilities
- @uiw/react-md-editor
And confirm breadcrumb component exists in src/components/ui/breadcrumb.tsx
  </verify>
  <done>
All Phase 6 dependencies installed. Breadcrumb component added via shadcn CLI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create avatar utility functions</name>
  <files>sidekiq-webapp/src/lib/utils/avatar.ts</files>
  <action>
Create avatar utilities following RESEARCH.md patterns:

```typescript
/**
 * Avatar utility functions for Sidekiq.
 * Provides deterministic color generation from names and initials extraction.
 */

/**
 * Preset color palette for avatar backgrounds.
 * 12 distinct colors with good contrast for white text.
 */
export const AVATAR_COLORS = [
  "#ef4444", // red
  "#f97316", // orange
  "#f59e0b", // amber
  "#84cc16", // lime
  "#22c55e", // green
  "#14b8a6", // teal
  "#06b6d4", // cyan
  "#3b82f6", // blue
  "#6366f1", // indigo (default)
  "#8b5cf6", // violet
  "#a855f7", // purple
  "#ec4899", // pink
] as const;

export type AvatarColor = (typeof AVATAR_COLORS)[number];

/**
 * Generate a deterministic color from a name string.
 * Uses djb2 hash algorithm for consistent results across sessions.
 *
 * @param name - The name to generate color from
 * @returns Hex color string from AVATAR_COLORS palette
 *
 * @example
 * generateColorFromName("My Assistant") // "#6366f1"
 * generateColorFromName("Code Helper")  // "#22c55e"
 */
export function generateColorFromName(name: string): AvatarColor {
  let hash = 0;
  const normalizedName = name.toLowerCase().trim();

  for (let i = 0; i < normalizedName.length; i++) {
    // djb2 hash algorithm
    hash = normalizedName.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash; // Convert to 32-bit integer
  }

  const index = Math.abs(hash) % AVATAR_COLORS.length;
  return AVATAR_COLORS[index];
}

/**
 * Extract initials from a name string.
 * - Single word: first 2 characters (e.g., "Assistant" -> "AS")
 * - Multiple words: first letter of first 2 words (e.g., "Code Helper" -> "CH")
 * - Empty/whitespace: returns "?"
 *
 * @param name - The name to extract initials from
 * @returns 1-2 character uppercase string
 *
 * @example
 * getInitials("My Assistant")  // "MA"
 * getInitials("CodeHelper")    // "CO"
 * getInitials("A")             // "A"
 */
export function getInitials(name: string): string {
  const words = name.trim().split(/\s+/).filter(Boolean);

  if (words.length === 0) {
    return "?";
  }

  if (words.length === 1) {
    // Single word: take first 2 characters
    return words[0].slice(0, 2).toUpperCase();
  }

  // Multiple words: first letter of first 2 words
  return (words[0][0] + words[1][0]).toUpperCase();
}

/**
 * Create default avatar configuration for a name.
 * Auto-generates color from name and uses initials type.
 *
 * @param name - The name to create avatar for
 * @returns Avatar configuration object
 */
export function createDefaultAvatar(name: string) {
  return {
    type: "initials" as const,
    color: generateColorFromName(name),
  };
}
```
  </action>
  <verify>
Create a simple test:
```bash
cd sidekiq-webapp && pnpm tsc --noEmit
```
Verify functions are exported correctly and types compile.
  </verify>
  <done>
Avatar utilities created: generateColorFromName (deterministic hash), getInitials (smart extraction), AVATAR_COLORS palette, createDefaultAvatar helper.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sidekiq actions hook with optimistic updates</name>
  <files>
sidekiq-webapp/src/hooks/use-sidekiq-actions.ts
sidekiq-webapp/src/hooks/use-view-preference.ts
  </files>
  <action>
Create mutation hooks following use-thread-actions.ts pattern:

**1. Create `src/hooks/use-sidekiq-actions.ts`:**

```typescript
"use client";

import { useCallback } from "react";
import { toast } from "sonner";

import { api } from "@sidekiq/trpc/react";
import type {
  CreateSidekiqInput,
  UpdateSidekiqInput,
  DeleteSidekiqInput,
} from "@sidekiq/lib/validations/sidekiq";

/**
 * Hook providing Sidekiq mutation actions with optimistic updates.
 *
 * Uses tRPC's useUtils for cache invalidation and optimistic updates.
 * All mutations show toast notifications on success/error.
 *
 * @returns Object with mutation functions and loading states
 *
 * @example
 * ```tsx
 * const { createSidekiq, deleteSidekiq, isCreating } = useSidekiqActions();
 *
 * const handleCreate = async () => {
 *   const result = await createSidekiq({ name: "My Assistant", instructions: "..." });
 *   if (result) router.push(`/sidekiqs/${result.id}/edit`);
 * };
 * ```
 */
export function useSidekiqActions() {
  const utils = api.useUtils();

  const createMutation = api.sidekiq.create.useMutation({
    onSuccess: () => {
      utils.sidekiq.list.invalidate();
      toast.success("Sidekiq created successfully");
    },
    onError: (error) => {
      if (error.data?.code === "TOO_MANY_REQUESTS") {
        toast.error(error.message);
      } else if (error.data?.code === "CONFLICT") {
        toast.error("A Sidekiq with this name already exists");
      } else {
        toast.error("Failed to create Sidekiq");
      }
    },
  });

  const updateMutation = api.sidekiq.update.useMutation({
    onSuccess: () => {
      utils.sidekiq.list.invalidate();
      toast.success("Sidekiq updated successfully");
    },
    onError: (error) => {
      if (error.data?.code === "CONFLICT") {
        toast.error("A Sidekiq with this name already exists");
      } else {
        toast.error("Failed to update Sidekiq");
      }
    },
  });

  const deleteMutation = api.sidekiq.delete.useMutation({
    onMutate: async ({ id }) => {
      // Cancel outgoing fetches
      await utils.sidekiq.list.cancel();

      // Snapshot previous value
      const previousData = utils.sidekiq.list.getData();

      // Optimistically remove from list
      utils.sidekiq.list.setData(undefined, (old) =>
        old?.filter((s) => s.id !== id)
      );

      return { previousData };
    },
    onError: (_error, _variables, context) => {
      // Rollback on error
      if (context?.previousData) {
        utils.sidekiq.list.setData(undefined, context.previousData);
      }
      toast.error("Failed to delete Sidekiq");
    },
    onSuccess: () => {
      toast.success("Sidekiq deleted");
    },
    onSettled: () => {
      utils.sidekiq.list.invalidate();
    },
  });

  const toggleFavoriteMutation = api.sidekiq.toggleFavorite.useMutation({
    onMutate: async ({ id }) => {
      await utils.sidekiq.list.cancel();
      const previousData = utils.sidekiq.list.getData();

      // Optimistically toggle favorite
      utils.sidekiq.list.setData(undefined, (old) =>
        old?.map((s) =>
          s.id === id ? { ...s, isFavorite: !s.isFavorite } : s
        )
      );

      return { previousData };
    },
    onError: (_error, _variables, context) => {
      if (context?.previousData) {
        utils.sidekiq.list.setData(undefined, context.previousData);
      }
      toast.error("Failed to update favorite");
    },
    onSettled: () => {
      utils.sidekiq.list.invalidate();
    },
  });

  const duplicateMutation = api.sidekiq.duplicate.useMutation({
    onSuccess: (result) => {
      utils.sidekiq.list.invalidate();
      toast.success(`Created "${result.name}"`);
    },
    onError: () => {
      toast.error("Failed to duplicate Sidekiq");
    },
  });

  // Wrapped functions with stable references
  const createSidekiq = useCallback(
    async (input: CreateSidekiqInput) => {
      try {
        return await createMutation.mutateAsync(input);
      } catch {
        return null;
      }
    },
    [createMutation]
  );

  const updateSidekiq = useCallback(
    async (input: UpdateSidekiqInput) => {
      try {
        return await updateMutation.mutateAsync(input);
      } catch {
        return null;
      }
    },
    [updateMutation]
  );

  const deleteSidekiq = useCallback(
    async (input: DeleteSidekiqInput) => {
      try {
        return await deleteMutation.mutateAsync(input);
      } catch {
        return null;
      }
    },
    [deleteMutation]
  );

  const toggleFavorite = useCallback(
    async (id: string) => {
      try {
        return await toggleFavoriteMutation.mutateAsync({ id });
      } catch {
        return null;
      }
    },
    [toggleFavoriteMutation]
  );

  const duplicateSidekiq = useCallback(
    async (id: string) => {
      try {
        return await duplicateMutation.mutateAsync({ id });
      } catch {
        return null;
      }
    },
    [duplicateMutation]
  );

  return {
    createSidekiq,
    updateSidekiq,
    deleteSidekiq,
    toggleFavorite,
    duplicateSidekiq,
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
    isTogglingFavorite: toggleFavoriteMutation.isPending,
    isDuplicating: duplicateMutation.isPending,
  };
}
```

**2. Create `src/hooks/use-view-preference.ts`:**

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";

type ViewMode = "grid" | "list";

const STORAGE_KEY = "sidekiq-view-preference";
const DEFAULT_VIEW: ViewMode = "grid";

/**
 * Hook for persisted view preference (grid/list).
 * Stores preference in localStorage for persistence across sessions.
 *
 * @returns Object with viewMode state and setViewMode function
 *
 * @example
 * ```tsx
 * const { viewMode, setViewMode } = useViewPreference();
 *
 * <ToggleGroup value={viewMode} onValueChange={setViewMode}>
 *   <ToggleGroupItem value="grid">Grid</ToggleGroupItem>
 *   <ToggleGroupItem value="list">List</ToggleGroupItem>
 * </ToggleGroup>
 * ```
 */
export function useViewPreference() {
  // Initialize with default to avoid hydration mismatch
  const [viewMode, setViewModeState] = useState<ViewMode>(DEFAULT_VIEW);
  const [isHydrated, setIsHydrated] = useState(false);

  // Load from localStorage after mount (SSR-safe)
  useEffect(() => {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored === "grid" || stored === "list") {
      setViewModeState(stored);
    }
    setIsHydrated(true);
  }, []);

  const setViewMode = useCallback((mode: ViewMode) => {
    setViewModeState(mode);
    localStorage.setItem(STORAGE_KEY, mode);
  }, []);

  return {
    viewMode,
    setViewMode,
    isHydrated,
  };
}
```
  </action>
  <verify>
```bash
cd sidekiq-webapp && pnpm tsc --noEmit
```
Verify hooks compile and export correctly.
  </verify>
  <done>
Sidekiq actions hook created with optimistic updates for delete and toggleFavorite. View preference hook created with localStorage persistence and SSR-safe hydration.
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed: `pnpm list @dnd-kit/core @dnd-kit/sortable @uiw/react-md-editor`
2. Breadcrumb component exists: `ls sidekiq-webapp/src/components/ui/breadcrumb.tsx`
3. TypeScript compiles: `pnpm tsc --noEmit`
4. Imports resolve: No import errors when importing from new modules
</verification>

<success_criteria>
- @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities, @uiw/react-md-editor in package.json
- Avatar utils export generateColorFromName, getInitials, AVATAR_COLORS
- useSidekiqActions provides all CRUD operations with optimistic updates
- useViewPreference persists to localStorage and handles SSR hydration
</success_criteria>

<output>
After completion, create `.planning/phases/06-sidekiq-crud/06-02-SUMMARY.md`
</output>

---
phase: 06-sidekiq-crud
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekiq-webapp/src/server/db/schema.ts
  - sidekiq-webapp/src/lib/validations/sidekiq.ts
  - sidekiq-webapp/src/server/api/routers/sidekiq.ts
  - sidekiq-webapp/src/server/api/root.ts
autonomous: true

must_haves:
  truths:
    - "Sidekiq table has all required fields for CRUD operations"
    - "tRPC sidekiq router provides list, getById, create, update, delete mutations"
    - "Create mutation enforces rate limiting (25/hour)"
    - "Name uniqueness is enforced per user (case-insensitive)"
  artifacts:
    - path: "sidekiq-webapp/src/server/db/schema.ts"
      provides: "Extended sidekiq table schema"
      contains: "conversationStarters"
    - path: "sidekiq-webapp/src/lib/validations/sidekiq.ts"
      provides: "Zod schemas for sidekiq operations"
      exports: ["createSidekiqSchema", "updateSidekiqSchema", "deleteSidekiqSchema"]
    - path: "sidekiq-webapp/src/server/api/routers/sidekiq.ts"
      provides: "Sidekiq tRPC router with CRUD"
      exports: ["sidekiqRouter"]
  key_links:
    - from: "sidekiq-webapp/src/server/api/routers/sidekiq.ts"
      to: "sidekiq-webapp/src/lib/validations/sidekiq.ts"
      via: "input validation schemas"
      pattern: "createSidekiqSchema|updateSidekiqSchema"
    - from: "sidekiq-webapp/src/server/api/root.ts"
      to: "sidekiq-webapp/src/server/api/routers/sidekiq.ts"
      via: "router registration"
      pattern: "sidekiq: sidekiqRouter"
---

<objective>
Extend database schema and create tRPC router for Sidekiq CRUD operations.

Purpose: Establishes the data layer foundation for all Sidekiq features - without this, no Sidekiq UI can persist data.
Output: Extended schema with avatar/starters fields, validation schemas, fully functional tRPC router with rate limiting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-sidekiq-crud/06-CONTEXT.md
@.planning/phases/06-sidekiq-crud/06-RESEARCH.md

# Existing patterns to follow
@sidekiq-webapp/src/server/db/schema.ts
@sidekiq-webapp/src/server/api/routers/thread.ts
@sidekiq-webapp/src/lib/validations/thread.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend sidekiqs schema with new fields</name>
  <files>sidekiq-webapp/src/server/db/schema.ts</files>
  <action>
Extend the existing `sidekiqs` table with additional columns:

1. Add new columns to sidekiqs table:
   - `conversationStarters`: jsonb array of strings, default empty array
   - `defaultModel`: varchar(100) nullable - model ID to use for new chats
   - `avatar`: jsonb with structure `{ type: "initials" | "emoji", color: string, emoji?: string }`, default `{ type: "initials", color: "#6366f1" }`
   - `isFavorite`: boolean, default false - for sidebar pinning
   - `lastUsedAt`: timestamp nullable - updated when starting chat
   - `threadCount`: integer, default 0 - denormalized count for display

2. Add TypeScript interface for avatar JSONB:
```typescript
export interface SidekiqAvatar {
  type: "initials" | "emoji";
  color: string;
  emoji?: string;
}
```

3. Add index on `isFavorite` for sidebar queries:
   `index("sidekiq_favorite_idx").on(t.isFavorite)`

4. Add unique index for name uniqueness per user (case-insensitive):
   `uniqueIndex("sidekiq_owner_name_unique").on(t.ownerId, sql\`LOWER(${t.name})\`)`

Note: Do NOT add a tags junction table yet - tags are deferred to a future iteration per CONTEXT.md Claude's Discretion.
  </action>
  <verify>
Run `pnpm db:push` in sidekiq-webapp to apply schema changes. Check for errors.
  </verify>
  <done>
Schema extended with conversationStarters, defaultModel, avatar, isFavorite, lastUsedAt, threadCount columns. Unique constraint on (ownerId, LOWER(name)) enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Sidekiq validation schemas</name>
  <files>sidekiq-webapp/src/lib/validations/sidekiq.ts</files>
  <action>
Create Zod validation schemas for Sidekiq operations following the thread.ts pattern:

```typescript
import { z } from "zod";

/**
 * Sidekiq avatar configuration.
 * Supports either text initials or emoji with customizable background color.
 */
export const sidekiqAvatarSchema = z.object({
  type: z.enum(["initials", "emoji"]),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, "Invalid hex color"),
  emoji: z.string().optional(),
});

export type SidekiqAvatar = z.infer<typeof sidekiqAvatarSchema>;

/**
 * Schema for creating a new Sidekiq.
 * Per CONTEXT.md limits: name 100 chars, description 500 chars, instructions 8000 chars.
 */
export const createSidekiqSchema = z.object({
  name: z.string()
    .min(1, "Name is required")
    .max(100, "Name must be at most 100 characters"),
  description: z.string()
    .max(500, "Description must be at most 500 characters")
    .optional()
    .nullable(),
  instructions: z.string()
    .max(8000, "Instructions must be at most 8000 characters"),
  conversationStarters: z.array(
    z.string().max(200, "Each starter must be at most 200 characters")
  ).max(6, "Maximum 6 conversation starters").default([]),
  defaultModel: z.string().optional().nullable(),
  avatar: sidekiqAvatarSchema.default({ type: "initials", color: "#6366f1" }),
});

export type CreateSidekiqInput = z.infer<typeof createSidekiqSchema>;

/**
 * Schema for updating an existing Sidekiq.
 * All fields optional except id (uses partial of create schema).
 */
export const updateSidekiqSchema = z.object({
  id: z.string().min(1, "Sidekiq ID is required"),
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional().nullable(),
  instructions: z.string().max(8000).optional(),
  conversationStarters: z.array(z.string().max(200)).max(6).optional(),
  defaultModel: z.string().optional().nullable(),
  avatar: sidekiqAvatarSchema.optional(),
});

export type UpdateSidekiqInput = z.infer<typeof updateSidekiqSchema>;

/**
 * Schema for deleting a Sidekiq.
 * Includes option to cascade delete associated threads.
 */
export const deleteSidekiqSchema = z.object({
  id: z.string().min(1, "Sidekiq ID is required"),
  deleteThreads: z.boolean().default(false),
});

export type DeleteSidekiqInput = z.infer<typeof deleteSidekiqSchema>;

/**
 * Schema for toggling favorite status.
 */
export const toggleFavoriteSchema = z.object({
  id: z.string().min(1, "Sidekiq ID is required"),
});

export type ToggleFavoriteInput = z.infer<typeof toggleFavoriteSchema>;

/**
 * Schema for duplicating a Sidekiq.
 */
export const duplicateSidekiqSchema = z.object({
  id: z.string().min(1, "Sidekiq ID is required"),
});

export type DuplicateSidekiqInput = z.infer<typeof duplicateSidekiqSchema>;

/**
 * Schema for listing sidekiqs with optional filters.
 */
export const listSidekiqsSchema = z.object({
  includeThreadCount: z.boolean().optional().default(true),
}).optional();

export type ListSidekiqsInput = z.infer<typeof listSidekiqsSchema>;

/**
 * Schema for getting a single sidekiq by ID.
 */
export const getSidekiqByIdSchema = z.object({
  id: z.string().min(1, "Sidekiq ID is required"),
});

export type GetSidekiqByIdInput = z.infer<typeof getSidekiqByIdSchema>;
```
  </action>
  <verify>
Run TypeScript check: `cd sidekiq-webapp && pnpm tsc --noEmit`. Schemas should compile without errors.
  </verify>
  <done>
Validation schemas exported: createSidekiqSchema, updateSidekiqSchema, deleteSidekiqSchema, toggleFavoriteSchema, duplicateSidekiqSchema with proper type exports.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Sidekiq tRPC router with CRUD and rate limiting</name>
  <files>
sidekiq-webapp/src/server/api/routers/sidekiq.ts
sidekiq-webapp/src/server/api/root.ts
  </files>
  <action>
Create the sidekiq tRPC router following the thread.ts pattern:

1. Install rate limiting package:
```bash
cd sidekiq-webapp && pnpm add @trpc-limiter/memory
```

2. Create sidekiq router at `src/server/api/routers/sidekiq.ts`:

```typescript
import { TRPCError } from "@trpc/server";
import { and, desc, eq, sql } from "drizzle-orm";
import { nanoid } from "nanoid";

import { createTRPCRouter, protectedProcedure } from "@sidekiq/server/api/trpc";
import { sidekiqs, threads } from "@sidekiq/server/db/schema";
import {
  createSidekiqSchema,
  updateSidekiqSchema,
  deleteSidekiqSchema,
  toggleFavoriteSchema,
  duplicateSidekiqSchema,
  listSidekiqsSchema,
  getSidekiqByIdSchema,
} from "@sidekiq/lib/validations/sidekiq";
import { createTRPCStoreLimiter } from "@trpc-limiter/memory";

// Rate limiter: 25 creations per hour per user (CONTEXT.md says 20-30)
const createRateLimiter = createTRPCStoreLimiter({
  max: 25,
  windowMs: 60 * 60 * 1000, // 1 hour
});

export const sidekiqRouter = createTRPCRouter({
  list: protectedProcedure
    .input(listSidekiqsSchema)
    .query(async ({ ctx }) => {
      return ctx.db.query.sidekiqs.findMany({
        where: eq(sidekiqs.ownerId, ctx.session.user.id),
        orderBy: [desc(sidekiqs.isFavorite), desc(sidekiqs.lastUsedAt), desc(sidekiqs.createdAt)],
        columns: {
          id: true,
          name: true,
          description: true,
          avatar: true,
          isFavorite: true,
          lastUsedAt: true,
          threadCount: true,
          createdAt: true,
        },
      });
    }),

  getById: protectedProcedure
    .input(getSidekiqByIdSchema)
    .query(async ({ ctx, input }) => {
      const sidekiq = await ctx.db.query.sidekiqs.findFirst({
        where: and(
          eq(sidekiqs.id, input.id),
          eq(sidekiqs.ownerId, ctx.session.user.id),
        ),
      });
      if (!sidekiq) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Sidekiq not found" });
      }
      return sidekiq;
    }),

  create: protectedProcedure
    .input(createSidekiqSchema)
    .mutation(async ({ ctx, input }) => {
      // Rate limiting check
      const fingerprint = ctx.session.user.id;
      const result = await createRateLimiter.check(fingerprint);
      if (!result.success) {
        const retryMinutes = Math.ceil((result.reset - Date.now()) / 60000);
        throw new TRPCError({
          code: "TOO_MANY_REQUESTS",
          message: `Rate limit exceeded. Try again in ${retryMinutes} minute${retryMinutes > 1 ? "s" : ""}.`,
        });
      }

      // Check name uniqueness (case-insensitive)
      const existing = await ctx.db.query.sidekiqs.findFirst({
        where: and(
          eq(sidekiqs.ownerId, ctx.session.user.id),
          sql`LOWER(${sidekiqs.name}) = LOWER(${input.name})`,
        ),
      });
      if (existing) {
        throw new TRPCError({
          code: "CONFLICT",
          message: "A Sidekiq with this name already exists",
        });
      }

      const [created] = await ctx.db
        .insert(sidekiqs)
        .values({
          id: nanoid(),
          ownerId: ctx.session.user.id,
          name: input.name,
          description: input.description ?? null,
          instructions: input.instructions,
          conversationStarters: input.conversationStarters,
          defaultModel: input.defaultModel ?? null,
          avatar: input.avatar,
        })
        .returning();

      return created;
    }),

  update: protectedProcedure
    .input(updateSidekiqSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;

      // Check name uniqueness if name is being changed
      if (data.name) {
        const existing = await ctx.db.query.sidekiqs.findFirst({
          where: and(
            eq(sidekiqs.ownerId, ctx.session.user.id),
            sql`LOWER(${sidekiqs.name}) = LOWER(${data.name})`,
            sql`${sidekiqs.id} != ${id}`,
          ),
        });
        if (existing) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "A Sidekiq with this name already exists",
          });
        }
      }

      const [updated] = await ctx.db
        .update(sidekiqs)
        .set({ ...data, updatedAt: new Date() })
        .where(
          and(eq(sidekiqs.id, id), eq(sidekiqs.ownerId, ctx.session.user.id)),
        )
        .returning();

      if (!updated) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Sidekiq not found" });
      }
      return updated;
    }),

  delete: protectedProcedure
    .input(deleteSidekiqSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, deleteThreads } = input;

      // If user wants to delete threads too
      if (deleteThreads) {
        await ctx.db
          .delete(threads)
          .where(
            and(eq(threads.sidekiqId, id), eq(threads.userId, ctx.session.user.id)),
          );
      }

      const [deleted] = await ctx.db
        .delete(sidekiqs)
        .where(
          and(eq(sidekiqs.id, id), eq(sidekiqs.ownerId, ctx.session.user.id)),
        )
        .returning({ id: sidekiqs.id });

      if (!deleted) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Sidekiq not found" });
      }
      return { success: true, deletedId: deleted.id };
    }),

  toggleFavorite: protectedProcedure
    .input(toggleFavoriteSchema)
    .mutation(async ({ ctx, input }) => {
      const sidekiq = await ctx.db.query.sidekiqs.findFirst({
        where: and(
          eq(sidekiqs.id, input.id),
          eq(sidekiqs.ownerId, ctx.session.user.id),
        ),
        columns: { isFavorite: true },
      });

      if (!sidekiq) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Sidekiq not found" });
      }

      const [updated] = await ctx.db
        .update(sidekiqs)
        .set({ isFavorite: !sidekiq.isFavorite, updatedAt: new Date() })
        .where(
          and(eq(sidekiqs.id, input.id), eq(sidekiqs.ownerId, ctx.session.user.id)),
        )
        .returning({ id: sidekiqs.id, isFavorite: sidekiqs.isFavorite });

      return updated;
    }),

  duplicate: protectedProcedure
    .input(duplicateSidekiqSchema)
    .mutation(async ({ ctx, input }) => {
      const original = await ctx.db.query.sidekiqs.findFirst({
        where: and(
          eq(sidekiqs.id, input.id),
          eq(sidekiqs.ownerId, ctx.session.user.id),
        ),
      });

      if (!original) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Sidekiq not found" });
      }

      // Generate unique name: "Copy of [Name]" or "Copy of [Name] (2)" etc.
      let copyName = `Copy of ${original.name}`;
      let counter = 1;
      while (true) {
        const exists = await ctx.db.query.sidekiqs.findFirst({
          where: and(
            eq(sidekiqs.ownerId, ctx.session.user.id),
            sql`LOWER(${sidekiqs.name}) = LOWER(${copyName})`,
          ),
        });
        if (!exists) break;
        counter++;
        copyName = `Copy of ${original.name} (${counter})`;
      }

      const [created] = await ctx.db
        .insert(sidekiqs)
        .values({
          id: nanoid(),
          ownerId: ctx.session.user.id,
          name: copyName,
          description: original.description,
          instructions: original.instructions,
          conversationStarters: original.conversationStarters,
          defaultModel: original.defaultModel,
          avatar: original.avatar,
          isFavorite: false,
          threadCount: 0,
          lastUsedAt: null,
        })
        .returning();

      return created;
    }),
});
```

3. Register the router in `src/server/api/root.ts`:
   - Import: `import { sidekiqRouter } from "./routers/sidekiq";`
   - Add to appRouter: `sidekiq: sidekiqRouter,`
  </action>
  <verify>
1. Run `cd sidekiq-webapp && pnpm tsc --noEmit` - no errors
2. Start dev server and verify routes are accessible (won't error on startup)
  </verify>
  <done>
Sidekiq tRPC router with list, getById, create, update, delete, toggleFavorite, duplicate mutations. Rate limiting enforced on create (25/hour). Router registered in appRouter.
  </done>
</task>

</tasks>

<verification>
1. Schema changes applied: `pnpm db:push` succeeds
2. TypeScript compiles: `pnpm tsc --noEmit` passes
3. Dev server starts: `pnpm dev` runs without errors
4. tRPC introspection: router endpoints visible in tRPC panel (if enabled)
</verification>

<success_criteria>
- sidekiqs table has new columns: conversationStarters, defaultModel, avatar, isFavorite, lastUsedAt, threadCount
- Unique index on (ownerId, LOWER(name)) prevents duplicate names
- sidekiqRouter exports all CRUD operations
- Rate limiting middleware blocks >25 creates/hour
- All validation schemas type-checked and exported
</success_criteria>

<output>
After completion, create `.planning/phases/06-sidekiq-crud/06-01-SUMMARY.md`
</output>

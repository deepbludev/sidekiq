---
phase: 08-team-foundation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - sidekiq-webapp/src/server/api/routers/team.ts
  - sidekiq-webapp/src/server/api/root.ts
  - sidekiq-webapp/src/lib/emails/team-invite.ts
autonomous: true

must_haves:
  truths:
    - "User can create a team with name and avatar"
    - "Team owner is automatically added as member with owner role"
    - "User can list their teams (owned + member)"
    - "User can update team name and avatar"
    - "Only team owner can delete the team"
  artifacts:
    - path: "sidekiq-webapp/src/server/api/routers/team.ts"
      provides: "Team CRUD operations via tRPC"
      exports: ["teamRouter"]
    - path: "sidekiq-webapp/src/lib/emails/team-invite.ts"
      provides: "Email template and send function for invites"
      exports: ["sendTeamInviteEmail"]
  key_links:
    - from: "sidekiq-webapp/src/server/api/root.ts"
      to: "sidekiq-webapp/src/server/api/routers/team.ts"
      via: "router registration"
      pattern: "team: teamRouter"
    - from: "sidekiq-webapp/src/server/api/routers/team.ts"
      to: "sidekiq-webapp/src/lib/team-permissions.ts"
      via: "permission checks"
      pattern: "canInvite|canRemoveMember"
---

<objective>
Create the team tRPC router with CRUD operations and member management.

Purpose: Enable users to create teams, manage team settings, and handle basic member operations through the API layer. This builds on the schema and validation from Plan 01.

Output: Fully functional team router with create, list, getById, update, delete operations, plus member listing and role management.
</objective>

<execution_context>
@/Users/carlocasorzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/carlocasorzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-team-foundation/08-CONTEXT.md
@.planning/phases/08-team-foundation/08-RESEARCH.md
@.planning/phases/08-team-foundation/08-01-SUMMARY.md
@sidekiq-webapp/src/server/api/routers/sidekiq.ts
@sidekiq-webapp/src/server/better-auth/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email template function for team invites</name>
  <files>sidekiq-webapp/src/lib/emails/team-invite.ts</files>
  <action>
Create the email directory and team invite email function following the pattern from better-auth password reset:

```typescript
import { Resend } from "resend";
import { env } from "@sidekiq/env";

const resend = env.RESEND_API_KEY ? new Resend(env.RESEND_API_KEY) : null;

interface SendTeamInviteEmailParams {
  to: string;
  teamName: string;
  inviterName: string;
  inviteToken: string;
}

/**
 * Send team invitation email via Resend.
 * Falls back to console logging in development when RESEND_API_KEY not set.
 *
 * @returns The invite URL (useful for copyable link feature)
 */
export async function sendTeamInviteEmail({
  to,
  teamName,
  inviterName,
  inviteToken,
}: SendTeamInviteEmailParams): Promise<string> {
  const baseUrl = env.BETTER_AUTH_URL;
  const inviteUrl = `${baseUrl}/invite/${inviteToken}`;

  console.log(`[Team] Invite created for ${to} to join ${teamName}`);
  console.log(`[Team] Invite URL: ${inviteUrl}`);

  if (!resend) {
    console.log(`[Team] Resend not configured - email not sent`);
    return inviteUrl;
  }

  try {
    const { data, error } = await resend.emails.send({
      from: env.EMAIL_FROM ?? "onboarding@resend.dev",
      to,
      subject: `You're invited to join ${teamName} on Sidekiq`,
      html: `
        <div style="font-family: sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
          <h1 style="color: #18181b; margin-bottom: 16px;">Join ${teamName}</h1>
          <p style="color: #52525b; line-height: 1.6;">
            <strong>${inviterName}</strong> has invited you to join their team on Sidekiq.
          </p>
          <p style="color: #52525b; line-height: 1.6;">
            Sidekiq is a premium AI chat application with custom assistants and team collaboration.
          </p>
          <a href="${inviteUrl}" style="display: inline-block; background-color: #18181b; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 24px 0; font-weight: 500;">
            Accept Invitation
          </a>
          <p style="color: #71717a; font-size: 14px;">
            This invitation expires in 7 days. If you didn't expect this invitation, you can safely ignore this email.
          </p>
          <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;" />
          <p style="color: #9ca3af; font-size: 12px;">
            If the button doesn't work, copy and paste this link into your browser:<br />
            <a href="${inviteUrl}" style="color: #6366f1;">${inviteUrl}</a>
          </p>
        </div>
      `,
    });

    if (error) {
      console.error(`[Team] Resend error:`, error);
      throw new Error(error.message);
    }

    console.log(`[Team] Invite email sent successfully. ID: ${data?.id}`);
  } catch (err) {
    console.error(`[Team] Failed to send invite email:`, err);
    throw err;
  }

  return inviteUrl;
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify imports resolve correctly</verify>
  <done>
- Email template follows password reset pattern
- Console fallback for development
- Returns invite URL for copyable link feature
  </done>
</task>

<task type="auto">
  <name>Task 2: Create team tRPC router with CRUD and member operations</name>
  <files>sidekiq-webapp/src/server/api/routers/team.ts</files>
  <action>
Create team router following the sidekiq router pattern:

```typescript
import { TRPCError } from "@trpc/server";
import { and, desc, eq, gt, isNull, sql } from "drizzle-orm";
import { nanoid } from "nanoid";
import { addDays } from "date-fns";

import {
  createTeamSchema,
  updateTeamSchema,
  deleteTeamSchema,
  getTeamByIdSchema,
  inviteMemberSchema,
  acceptInviteSchema,
  revokeInviteSchema,
  resendInviteSchema,
  removeMemberSchema,
  changeRoleSchema,
  transferOwnershipSchema,
  leaveTeamSchema,
} from "@sidekiq/lib/validations/team";
import {
  canInvite,
  canRemoveMember,
  canChangeRole,
  canTransferOwnership,
  canDeleteTeam,
  canLeaveTeam,
  canRevokeInvite,
} from "@sidekiq/lib/team-permissions";
import { sendTeamInviteEmail } from "@sidekiq/lib/emails/team-invite";
import { createTRPCRouter, protectedProcedure, publicProcedure } from "@sidekiq/server/api/trpc";
import { teams, teamMembers, teamInvites, user } from "@sidekiq/server/db/schema";

const INVITE_TOKEN_LENGTH = 32;
const INVITE_EXPIRY_DAYS = 7;
const MAX_PENDING_INVITES_PER_TEAM = 20;

/**
 * Helper to get user's role in a team.
 * Returns null if user is not a member.
 */
async function getUserTeamRole(
  db: typeof import("@sidekiq/server/db").db,
  teamId: string,
  userId: string
) {
  const membership = await db.query.teamMembers.findFirst({
    where: and(eq(teamMembers.teamId, teamId), eq(teamMembers.userId, userId)),
    columns: { role: true },
  });
  return membership?.role ?? null;
}

export const teamRouter = createTRPCRouter({
  /**
   * List all teams the user is a member of.
   * Includes owned teams and teams they've joined.
   */
  list: protectedProcedure.query(async ({ ctx }) => {
    const memberships = await ctx.db.query.teamMembers.findMany({
      where: eq(teamMembers.userId, ctx.session.user.id),
      with: {
        team: true,
      },
      orderBy: [desc(teamMembers.joinedAt)],
    });

    return memberships.map((m) => ({
      ...m.team,
      role: m.role,
      joinedAt: m.joinedAt,
    }));
  }),

  /**
   * Get a team by ID with member count.
   * User must be a member of the team.
   */
  getById: protectedProcedure
    .input(getTeamByIdSchema)
    .query(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.id, ctx.session.user.id);
      if (!role) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Team not found",
        });
      }

      const team = await ctx.db.query.teams.findFirst({
        where: eq(teams.id, input.id),
      });

      if (!team) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Team not found",
        });
      }

      // Get member count
      const memberCount = await ctx.db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(eq(teamMembers.teamId, input.id));

      return {
        ...team,
        memberCount: memberCount[0]?.count ?? 0,
        userRole: role,
      };
    }),

  /**
   * Create a new team.
   * Creator becomes the owner and first member.
   */
  create: protectedProcedure
    .input(createTeamSchema)
    .mutation(async ({ ctx, input }) => {
      const teamId = nanoid();

      const [team] = await ctx.db
        .insert(teams)
        .values({
          id: teamId,
          name: input.name,
          ownerId: ctx.session.user.id,
          avatar: input.avatar,
        })
        .returning();

      // Add creator as owner member
      await ctx.db.insert(teamMembers).values({
        teamId,
        userId: ctx.session.user.id,
        role: "owner",
      });

      return team;
    }),

  /**
   * Update team name and/or avatar.
   * Requires owner or admin role.
   */
  update: protectedProcedure
    .input(updateTeamSchema)
    .mutation(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.id, ctx.session.user.id);
      if (!role || (role !== "owner" && role !== "admin")) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Only owners and admins can update team settings",
        });
      }

      const { id, ...data } = input;

      const [updated] = await ctx.db
        .update(teams)
        .set({ ...data, updatedAt: new Date() })
        .where(eq(teams.id, id))
        .returning();

      if (!updated) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Team not found",
        });
      }

      return updated;
    }),

  /**
   * Delete a team.
   * Only the owner can delete.
   */
  delete: protectedProcedure
    .input(deleteTeamSchema)
    .mutation(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.id, ctx.session.user.id);
      if (!canDeleteTeam(role as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Only the team owner can delete the team",
        });
      }

      const [deleted] = await ctx.db
        .delete(teams)
        .where(eq(teams.id, input.id))
        .returning({ id: teams.id });

      return { success: true, deletedId: deleted?.id };
    }),

  /**
   * List team members with their roles.
   * User must be a member of the team.
   */
  listMembers: protectedProcedure
    .input(getTeamByIdSchema)
    .query(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.id, ctx.session.user.id);
      if (!role) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Team not found",
        });
      }

      const members = await ctx.db.query.teamMembers.findMany({
        where: eq(teamMembers.teamId, input.id),
        with: {
          user: {
            columns: {
              id: true,
              name: true,
              email: true,
              image: true,
            },
          },
        },
        orderBy: [
          // Owner first, then admin, then member
          sql`CASE ${teamMembers.role} WHEN 'owner' THEN 0 WHEN 'admin' THEN 1 ELSE 2 END`,
          desc(teamMembers.joinedAt),
        ],
      });

      return members.map((m) => ({
        userId: m.userId,
        role: m.role,
        joinedAt: m.joinedAt,
        user: m.user,
      }));
    }),

  /**
   * List pending invites for a team.
   * Requires owner or admin role.
   */
  listInvites: protectedProcedure
    .input(getTeamByIdSchema)
    .query(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.id, ctx.session.user.id);
      if (!canInvite(role as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to view invites",
        });
      }

      const invites = await ctx.db.query.teamInvites.findMany({
        where: and(
          eq(teamInvites.teamId, input.id),
          isNull(teamInvites.acceptedAt),
          isNull(teamInvites.rejectedAt),
          gt(teamInvites.expiresAt, new Date())
        ),
        orderBy: [desc(teamInvites.createdAt)],
      });

      return invites.map((i) => ({
        id: i.id,
        email: i.email,
        expiresAt: i.expiresAt,
        createdAt: i.createdAt,
      }));
    }),

  /**
   * Invite a member to the team.
   * Returns the invite URL for manual sharing.
   */
  invite: protectedProcedure
    .input(inviteMemberSchema)
    .mutation(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.teamId, ctx.session.user.id);
      if (!canInvite(role as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to invite members",
        });
      }

      // Check team exists and get details
      const team = await ctx.db.query.teams.findFirst({
        where: eq(teams.id, input.teamId),
      });

      if (!team) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Team not found",
        });
      }

      // Check member limit
      const memberCount = await ctx.db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(eq(teamMembers.teamId, input.teamId));

      if ((memberCount[0]?.count ?? 0) >= team.memberLimit) {
        throw new TRPCError({
          code: "PRECONDITION_FAILED",
          message: `Team has reached the member limit of ${team.memberLimit}`,
        });
      }

      // Check if already a member (case-insensitive email)
      const existingMember = await ctx.db
        .select({ userId: user.id })
        .from(user)
        .innerJoin(teamMembers, eq(teamMembers.userId, user.id))
        .where(
          and(
            eq(teamMembers.teamId, input.teamId),
            sql`LOWER(${user.email}) = ${input.email.toLowerCase()}`
          )
        );

      if (existingMember.length > 0) {
        throw new TRPCError({
          code: "CONFLICT",
          message: "This user is already a member of the team",
        });
      }

      // Check pending invite count
      const pendingInvites = await ctx.db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamInvites)
        .where(
          and(
            eq(teamInvites.teamId, input.teamId),
            isNull(teamInvites.acceptedAt),
            isNull(teamInvites.rejectedAt),
            gt(teamInvites.expiresAt, new Date())
          )
        );

      if ((pendingInvites[0]?.count ?? 0) >= MAX_PENDING_INVITES_PER_TEAM) {
        throw new TRPCError({
          code: "PRECONDITION_FAILED",
          message: "Too many pending invites. Please revoke some before inviting more.",
        });
      }

      // Check if there's already a pending invite for this email
      const existingInvite = await ctx.db.query.teamInvites.findFirst({
        where: and(
          eq(teamInvites.teamId, input.teamId),
          sql`LOWER(${teamInvites.email}) = ${input.email.toLowerCase()}`,
          isNull(teamInvites.acceptedAt),
          isNull(teamInvites.rejectedAt),
          gt(teamInvites.expiresAt, new Date())
        ),
      });

      if (existingInvite) {
        throw new TRPCError({
          code: "CONFLICT",
          message: "An invite for this email is already pending",
        });
      }

      // Create invite
      const token = nanoid(INVITE_TOKEN_LENGTH);
      const expiresAt = addDays(new Date(), INVITE_EXPIRY_DAYS);

      const [invite] = await ctx.db
        .insert(teamInvites)
        .values({
          id: nanoid(),
          teamId: input.teamId,
          email: input.email.toLowerCase(),
          token,
          expiresAt,
        })
        .returning();

      // Send email if requested
      let inviteUrl: string;
      if (input.sendEmail) {
        inviteUrl = await sendTeamInviteEmail({
          to: input.email,
          teamName: team.name,
          inviterName: ctx.session.user.name,
          inviteToken: token,
        });
      } else {
        // Generate URL without sending email
        const { env } = await import("@sidekiq/env");
        inviteUrl = `${env.BETTER_AUTH_URL}/invite/${token}`;
      }

      return {
        id: invite!.id,
        email: invite!.email,
        expiresAt: invite!.expiresAt,
        inviteUrl,
      };
    }),

  /**
   * Accept a team invite.
   * Public procedure - user may need to authenticate first.
   */
  acceptInvite: protectedProcedure
    .input(acceptInviteSchema)
    .mutation(async ({ ctx, input }) => {
      // Use transaction to prevent race condition
      return await ctx.db.transaction(async (tx) => {
        const invite = await tx.query.teamInvites.findFirst({
          where: and(
            eq(teamInvites.token, input.token),
            isNull(teamInvites.acceptedAt),
            isNull(teamInvites.rejectedAt),
            gt(teamInvites.expiresAt, new Date())
          ),
          with: { team: true },
        });

        if (!invite) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Invalid or expired invite",
          });
        }

        // Verify email matches (case-insensitive)
        if (invite.email.toLowerCase() !== ctx.session.user.email.toLowerCase()) {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "This invite was sent to a different email address",
          });
        }

        // Check if already a member
        const existingMember = await tx.query.teamMembers.findFirst({
          where: and(
            eq(teamMembers.teamId, invite.teamId),
            eq(teamMembers.userId, ctx.session.user.id)
          ),
        });

        if (existingMember) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "You are already a member of this team",
          });
        }

        // Mark invite as accepted
        await tx
          .update(teamInvites)
          .set({ acceptedAt: new Date() })
          .where(eq(teamInvites.id, invite.id));

        // Add member
        await tx.insert(teamMembers).values({
          teamId: invite.teamId,
          userId: ctx.session.user.id,
          role: "member",
        });

        return { team: invite.team };
      });
    }),

  /**
   * Get invite details by token (public, for invite acceptance page).
   */
  getInviteByToken: publicProcedure
    .input(acceptInviteSchema)
    .query(async ({ ctx, input }) => {
      const invite = await ctx.db.query.teamInvites.findFirst({
        where: and(
          eq(teamInvites.token, input.token),
          isNull(teamInvites.acceptedAt),
          isNull(teamInvites.rejectedAt)
        ),
        with: { team: true },
      });

      if (!invite) {
        return null;
      }

      const isExpired = invite.expiresAt < new Date();

      return {
        teamName: invite.team.name,
        teamAvatar: invite.team.avatar,
        email: invite.email,
        isExpired,
        expiresAt: invite.expiresAt,
      };
    }),

  /**
   * Revoke a pending invite.
   */
  revokeInvite: protectedProcedure
    .input(revokeInviteSchema)
    .mutation(async ({ ctx, input }) => {
      const invite = await ctx.db.query.teamInvites.findFirst({
        where: eq(teamInvites.id, input.inviteId),
      });

      if (!invite) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Invite not found",
        });
      }

      const role = await getUserTeamRole(ctx.db, invite.teamId, ctx.session.user.id);
      if (!canRevokeInvite(role as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to revoke invites",
        });
      }

      await ctx.db.delete(teamInvites).where(eq(teamInvites.id, input.inviteId));

      return { success: true };
    }),

  /**
   * Resend an invite (regenerates token, sends new email).
   */
  resendInvite: protectedProcedure
    .input(resendInviteSchema)
    .mutation(async ({ ctx, input }) => {
      const invite = await ctx.db.query.teamInvites.findFirst({
        where: and(
          eq(teamInvites.id, input.inviteId),
          isNull(teamInvites.acceptedAt),
          isNull(teamInvites.rejectedAt)
        ),
        with: { team: true },
      });

      if (!invite) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Invite not found or already used",
        });
      }

      const role = await getUserTeamRole(ctx.db, invite.teamId, ctx.session.user.id);
      if (!canInvite(role as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to resend invites",
        });
      }

      // Generate new token and expiry
      const newToken = nanoid(INVITE_TOKEN_LENGTH);
      const newExpiresAt = addDays(new Date(), INVITE_EXPIRY_DAYS);

      await ctx.db
        .update(teamInvites)
        .set({ token: newToken, expiresAt: newExpiresAt })
        .where(eq(teamInvites.id, input.inviteId));

      // Send email
      const inviteUrl = await sendTeamInviteEmail({
        to: invite.email,
        teamName: invite.team.name,
        inviterName: ctx.session.user.name,
        inviteToken: newToken,
      });

      return { inviteUrl };
    }),

  /**
   * Remove a member from the team.
   */
  removeMember: protectedProcedure
    .input(removeMemberSchema)
    .mutation(async ({ ctx, input }) => {
      const actorRole = await getUserTeamRole(ctx.db, input.teamId, ctx.session.user.id);
      const targetMember = await ctx.db.query.teamMembers.findFirst({
        where: and(
          eq(teamMembers.teamId, input.teamId),
          eq(teamMembers.userId, input.userId)
        ),
      });

      if (!targetMember) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Member not found",
        });
      }

      const isSelf = input.userId === ctx.session.user.id;
      if (!canRemoveMember(actorRole as any, targetMember.role, isSelf)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to remove this member",
        });
      }

      await ctx.db
        .delete(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, input.teamId),
            eq(teamMembers.userId, input.userId)
          )
        );

      return { success: true };
    }),

  /**
   * Change a member's role.
   */
  changeRole: protectedProcedure
    .input(changeRoleSchema)
    .mutation(async ({ ctx, input }) => {
      const actorRole = await getUserTeamRole(ctx.db, input.teamId, ctx.session.user.id);
      const targetMember = await ctx.db.query.teamMembers.findFirst({
        where: and(
          eq(teamMembers.teamId, input.teamId),
          eq(teamMembers.userId, input.userId)
        ),
      });

      if (!targetMember) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Member not found",
        });
      }

      if (!canChangeRole(actorRole as any, targetMember.role, input.newRole)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You don't have permission to change this member's role",
        });
      }

      const [updated] = await ctx.db
        .update(teamMembers)
        .set({ role: input.newRole })
        .where(
          and(
            eq(teamMembers.teamId, input.teamId),
            eq(teamMembers.userId, input.userId)
          )
        )
        .returning();

      return { userId: updated!.userId, role: updated!.role };
    }),

  /**
   * Transfer team ownership to another member.
   */
  transferOwnership: protectedProcedure
    .input(transferOwnershipSchema)
    .mutation(async ({ ctx, input }) => {
      const actorRole = await getUserTeamRole(ctx.db, input.teamId, ctx.session.user.id);
      if (!canTransferOwnership(actorRole as any)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Only the owner can transfer ownership",
        });
      }

      // Verify new owner is a member
      const newOwnerMember = await ctx.db.query.teamMembers.findFirst({
        where: and(
          eq(teamMembers.teamId, input.teamId),
          eq(teamMembers.userId, input.newOwnerId)
        ),
      });

      if (!newOwnerMember) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "User is not a member of this team",
        });
      }

      // Use transaction for atomic ownership transfer
      await ctx.db.transaction(async (tx) => {
        // Update team ownerId
        await tx
          .update(teams)
          .set({ ownerId: input.newOwnerId, updatedAt: new Date() })
          .where(eq(teams.id, input.teamId));

        // Change old owner to admin
        await tx
          .update(teamMembers)
          .set({ role: "admin" })
          .where(
            and(
              eq(teamMembers.teamId, input.teamId),
              eq(teamMembers.userId, ctx.session.user.id)
            )
          );

        // Change new owner to owner
        await tx
          .update(teamMembers)
          .set({ role: "owner" })
          .where(
            and(
              eq(teamMembers.teamId, input.teamId),
              eq(teamMembers.userId, input.newOwnerId)
            )
          );
      });

      return { success: true };
    }),

  /**
   * Leave a team (self-leave for non-owners).
   */
  leave: protectedProcedure
    .input(leaveTeamSchema)
    .mutation(async ({ ctx, input }) => {
      const role = await getUserTeamRole(ctx.db, input.teamId, ctx.session.user.id);
      if (!role) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "You are not a member of this team",
        });
      }

      if (!canLeaveTeam(role)) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Owner cannot leave the team. Transfer ownership first.",
        });
      }

      await ctx.db
        .delete(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, input.teamId),
            eq(teamMembers.userId, ctx.session.user.id)
          )
        );

      return { success: true };
    }),
});
```
  </action>
  <verify>Run `pnpm typecheck` to verify router compiles</verify>
  <done>
- All CRUD operations implemented
- Member management (list, remove, change role)
- Invite system (create, accept, revoke, resend, list)
- Ownership transfer
- Self-leave functionality
- Permission checks using team-permissions.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Register team router in root</name>
  <files>sidekiq-webapp/src/server/api/root.ts</files>
  <action>
Add team router to the root router:

1. Import teamRouter from team.ts
2. Add to appRouter: `team: teamRouter`

```typescript
import { teamRouter } from "@sidekiq/server/api/routers/team";

export const appRouter = createTRPCRouter({
  health: healthRouter,
  sidekiq: sidekiqRouter,
  thread: threadRouter,
  user: userRouter,
  team: teamRouter, // Add this line
});
```
  </action>
  <verify>Run `pnpm typecheck` and ensure AppRouter type includes team</verify>
  <done>
- teamRouter registered in appRouter
- TypeScript types correctly generated
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `pnpm typecheck` passes
2. `pnpm build` succeeds
3. Team router endpoints are available via tRPC
4. Email template function logs invite URL in development
</verification>

<success_criteria>
- Team CRUD operations work (create, read, update, delete)
- Member listing with role ordering works
- Invite system handles all cases (send, resend, accept, revoke)
- Permission checks prevent unauthorized actions
- Email sending works (or falls back to console in dev)
</success_criteria>

<output>
After completion, create `.planning/phases/08-team-foundation/08-02-SUMMARY.md`
</output>

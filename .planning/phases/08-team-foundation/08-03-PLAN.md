---
phase: 08-team-foundation
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - sidekiq-webapp/src/components/team/team-avatar.tsx
  - sidekiq-webapp/src/components/team/delete-team-dialog.tsx
  - sidekiq-webapp/src/components/team/remove-member-dialog.tsx
  - sidekiq-webapp/src/components/team/invite-member-dialog.tsx
  - sidekiq-webapp/src/hooks/use-member-search.ts
autonomous: true

must_haves:
  truths:
    - "Team avatar displays initials or emoji with colored background"
    - "Delete team dialog requires type-to-confirm"
    - "Remove member dialog shows confirmation"
    - "Invite dialog supports email input and copyable link"
    - "Member search filters by name or email"
  artifacts:
    - path: "sidekiq-webapp/src/components/team/team-avatar.tsx"
      provides: "Team avatar display component"
      exports: ["TeamAvatar"]
    - path: "sidekiq-webapp/src/components/team/delete-team-dialog.tsx"
      provides: "Type-to-confirm deletion dialog"
      exports: ["DeleteTeamDialog"]
    - path: "sidekiq-webapp/src/components/team/invite-member-dialog.tsx"
      provides: "Email invite form dialog"
      exports: ["InviteMemberDialog"]
    - path: "sidekiq-webapp/src/hooks/use-member-search.ts"
      provides: "Fuse.js search hook for member filtering"
      exports: ["useMemberSearch"]
  key_links:
    - from: "sidekiq-webapp/src/components/team/team-avatar.tsx"
      to: "sidekiq-webapp/src/components/sidekiq/sidekiq-avatar.tsx"
      via: "reuses avatar rendering pattern"
      pattern: "similar structure"
---

<objective>
Create reusable team UI components: dialogs and hooks for team management.

Purpose: Build the foundational UI components that will be composed into team settings and member management views. These components follow established patterns from Sidekiq components.

Output: Avatar display, delete confirmation dialog, member removal dialog, invite dialog, and member search hook.
</objective>

<execution_context>
@/Users/carlocasorzo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/carlocasorzo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-team-foundation/08-CONTEXT.md
@.planning/phases/08-team-foundation/08-RESEARCH.md
@.planning/phases/08-team-foundation/08-01-SUMMARY.md
@sidekiq-webapp/src/components/sidekiq/sidekiq-avatar.tsx
@sidekiq-webapp/src/components/sidekiq/delete-sidekiq-dialog.tsx
@sidekiq-webapp/src/hooks/use-thread-search.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create team avatar component</name>
  <files>sidekiq-webapp/src/components/team/team-avatar.tsx</files>
  <action>
Create a team avatar component following the sidekiq-avatar pattern:

```typescript
import { type SidekiqAvatar } from "@sidekiq/server/db/schema";
import { cn } from "@sidekiq/lib/utils";

interface TeamAvatarProps {
  avatar: SidekiqAvatar;
  name: string;
  size?: "sm" | "md" | "lg" | "xl";
  className?: string;
}

const sizeClasses = {
  sm: "h-6 w-6 text-xs",
  md: "h-8 w-8 text-sm",
  lg: "h-10 w-10 text-base",
  xl: "h-12 w-12 text-lg",
};

/**
 * Team avatar display component.
 * Renders either initials or emoji with a colored background.
 * Uses the same SidekiqAvatar type for consistency.
 *
 * @param props.avatar - Avatar configuration (type, color, emoji)
 * @param props.name - Team name (used for initials fallback)
 * @param props.size - Size variant (sm, md, lg, xl)
 * @param props.className - Additional CSS classes
 */
export function TeamAvatar({
  avatar,
  name,
  size = "md",
  className,
}: TeamAvatarProps) {
  // Generate initials from name (first two characters of first two words, or first two chars)
  const getInitials = (name: string): string => {
    const words = name.trim().split(/\s+/);
    if (words.length >= 2) {
      return (words[0]![0] + words[1]![0]).toUpperCase();
    }
    return name.slice(0, 2).toUpperCase();
  };

  const content = avatar.type === "emoji" && avatar.emoji
    ? avatar.emoji
    : getInitials(name);

  return (
    <div
      className={cn(
        "flex items-center justify-center rounded-lg font-medium text-white select-none",
        sizeClasses[size],
        className
      )}
      style={{ backgroundColor: avatar.color }}
    >
      {content}
    </div>
  );
}
```

Note: Using rounded-lg for teams (vs rounded-full for user avatars) to distinguish team avatars visually.
  </action>
  <verify>Run `pnpm typecheck` to verify component compiles</verify>
  <done>
- TeamAvatar component renders initials or emoji
- Uses SidekiqAvatar type for consistency
- Size variants match design needs
  </done>
</task>

<task type="auto">
  <name>Task 2: Create delete team dialog with type-to-confirm</name>
  <files>sidekiq-webapp/src/components/team/delete-team-dialog.tsx</files>
  <action>
Create delete team dialog following the delete-sidekiq-dialog pattern:

```typescript
"use client";

import { useState } from "react";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@sidekiq/components/ui/alert-dialog";
import { Input } from "@sidekiq/components/ui/input";
import { Label } from "@sidekiq/components/ui/label";

interface DeleteTeamDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  teamName: string;
  memberCount: number;
  isDeleting?: boolean;
}

/**
 * Type-to-confirm deletion dialog for Teams.
 * Per CONTEXT.md: user must type exact name to confirm.
 * Shows warning about member count and associated data.
 *
 * @param props.open - Whether the dialog is open
 * @param props.onOpenChange - Callback when dialog open state changes
 * @param props.onConfirm - Callback when deletion is confirmed
 * @param props.teamName - Name of the team being deleted
 * @param props.memberCount - Number of members in the team
 * @param props.isDeleting - Whether deletion is in progress
 */
export function DeleteTeamDialog({
  open,
  onOpenChange,
  onConfirm,
  teamName,
  memberCount,
  isDeleting = false,
}: DeleteTeamDialogProps) {
  const [confirmText, setConfirmText] = useState("");

  const isConfirmed = confirmText === teamName;

  const handleOpenChange = (open: boolean) => {
    if (!open) {
      setConfirmText("");
    }
    onOpenChange(open);
  };

  return (
    <AlertDialog open={open} onOpenChange={handleOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete &quot;{teamName}&quot;?</AlertDialogTitle>
          <AlertDialogDescription>
            This action cannot be undone. All team data including shared Sidekiqs
            will be affected.
            {memberCount > 1 && (
              <span className="mt-2 block text-amber-500 dark:text-amber-400">
                Warning: {memberCount - 1} other member{memberCount > 2 ? "s" : ""} will
                be removed from this team.
              </span>
            )}
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="confirm-team-name">
              Type{" "}
              <span className="font-mono font-semibold">{teamName}</span> to
              confirm
            </Label>
            <Input
              id="confirm-team-name"
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              placeholder={teamName}
              disabled={isDeleting}
              autoComplete="off"
            />
          </div>
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={!isConfirmed || isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting ? "Deleting..." : "Delete Team"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify dialog compiles</verify>
  <done>
- Type-to-confirm pattern matches Sidekiq dialog
- Shows member count warning
- Properly resets state on close
  </done>
</task>

<task type="auto">
  <name>Task 3: Create remove member and invite dialogs</name>
  <files>
    sidekiq-webapp/src/components/team/remove-member-dialog.tsx
    sidekiq-webapp/src/components/team/invite-member-dialog.tsx
  </files>
  <action>
Create two dialog components:

**remove-member-dialog.tsx:**
```typescript
"use client";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@sidekiq/components/ui/alert-dialog";

interface RemoveMemberDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  memberName: string;
  isRemoving?: boolean;
}

/**
 * Confirmation dialog for removing a team member.
 * Simpler than delete team - just requires button click confirmation.
 */
export function RemoveMemberDialog({
  open,
  onOpenChange,
  onConfirm,
  memberName,
  isRemoving = false,
}: RemoveMemberDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Remove {memberName}?</AlertDialogTitle>
          <AlertDialogDescription>
            This will remove {memberName} from the team. They will no longer have
            access to team Sidekiqs and can only rejoin via a new invite.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <AlertDialogFooter>
          <AlertDialogCancel disabled={isRemoving}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={isRemoving}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isRemoving ? "Removing..." : "Remove Member"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

**invite-member-dialog.tsx:**
```typescript
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Check, Copy, Mail, Link2 } from "lucide-react";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@sidekiq/components/ui/dialog";
import { Button } from "@sidekiq/components/ui/button";
import { Input } from "@sidekiq/components/ui/input";
import { Label } from "@sidekiq/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@sidekiq/components/ui/tabs";

const inviteSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
});

type InviteFormValues = z.infer<typeof inviteSchema>;

interface InviteMemberDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onInvite: (email: string, sendEmail: boolean) => Promise<{ inviteUrl: string }>;
  teamName: string;
  isInviting?: boolean;
}

/**
 * Dialog for inviting team members.
 * Supports both email invite and copyable link generation.
 * Per CONTEXT.md: Both options available.
 */
export function InviteMemberDialog({
  open,
  onOpenChange,
  onInvite,
  teamName,
  isInviting = false,
}: InviteMemberDialogProps) {
  const [inviteUrl, setInviteUrl] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);
  const [activeTab, setActiveTab] = useState<"email" | "link">("email");

  const form = useForm<InviteFormValues>({
    resolver: zodResolver(inviteSchema),
    defaultValues: { email: "" },
    mode: "onChange",
  });

  const handleOpenChange = (open: boolean) => {
    if (!open) {
      form.reset();
      setInviteUrl(null);
      setCopied(false);
      setActiveTab("email");
    }
    onOpenChange(open);
  };

  const handleInvite = async (sendEmail: boolean) => {
    const email = form.getValues("email");
    if (!email || form.formState.errors.email) return;

    try {
      const result = await onInvite(email, sendEmail);
      setInviteUrl(result.inviteUrl);
      if (!sendEmail) {
        setActiveTab("link");
      }
    } catch (error) {
      // Error handling done by parent
    }
  };

  const handleCopy = async () => {
    if (!inviteUrl) return;
    await navigator.clipboard.writeText(inviteUrl);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleSendAnother = () => {
    form.reset();
    setInviteUrl(null);
    setCopied(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Invite to {teamName}</DialogTitle>
          <DialogDescription>
            Send an email invitation or generate a shareable link.
          </DialogDescription>
        </DialogHeader>

        {inviteUrl ? (
          <div className="space-y-4 py-4">
            <div className="flex items-center gap-2 text-sm text-green-600 dark:text-green-400">
              <Check className="h-4 w-4" />
              <span>Invite created successfully!</span>
            </div>

            <div className="space-y-2">
              <Label>Invite Link</Label>
              <div className="flex gap-2">
                <Input
                  value={inviteUrl}
                  readOnly
                  className="font-mono text-xs"
                />
                <Button
                  type="button"
                  variant="outline"
                  size="icon"
                  onClick={handleCopy}
                >
                  {copied ? (
                    <Check className="h-4 w-4 text-green-500" />
                  ) : (
                    <Copy className="h-4 w-4" />
                  )}
                </Button>
              </div>
              <p className="text-xs text-muted-foreground">
                This link expires in 7 days.
              </p>
            </div>

            <DialogFooter className="gap-2 sm:gap-0">
              <Button variant="outline" onClick={handleSendAnother}>
                Invite Another
              </Button>
              <Button onClick={() => handleOpenChange(false)}>Done</Button>
            </DialogFooter>
          </div>
        ) : (
          <>
            <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as "email" | "link")}>
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="email" className="gap-2">
                  <Mail className="h-4 w-4" />
                  Email Invite
                </TabsTrigger>
                <TabsTrigger value="link" className="gap-2">
                  <Link2 className="h-4 w-4" />
                  Copy Link
                </TabsTrigger>
              </TabsList>

              <TabsContent value="email" className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="invite-email">Email address</Label>
                  <Input
                    id="invite-email"
                    type="email"
                    placeholder="colleague@example.com"
                    {...form.register("email")}
                    disabled={isInviting}
                  />
                  {form.formState.errors.email && (
                    <p className="text-xs text-destructive">
                      {form.formState.errors.email.message}
                    </p>
                  )}
                </div>
                <p className="text-xs text-muted-foreground">
                  We&apos;ll send an email with a link to join the team.
                </p>
              </TabsContent>

              <TabsContent value="link" className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="link-email">Email address</Label>
                  <Input
                    id="link-email"
                    type="email"
                    placeholder="colleague@example.com"
                    {...form.register("email")}
                    disabled={isInviting}
                  />
                  {form.formState.errors.email && (
                    <p className="text-xs text-destructive">
                      {form.formState.errors.email.message}
                    </p>
                  )}
                </div>
                <p className="text-xs text-muted-foreground">
                  Generate a link to share manually. The invite is still tied to this email.
                </p>
              </TabsContent>
            </Tabs>

            <DialogFooter>
              <Button
                onClick={() => handleInvite(activeTab === "email")}
                disabled={isInviting || !form.formState.isValid}
              >
                {isInviting
                  ? "Creating..."
                  : activeTab === "email"
                    ? "Send Invite"
                    : "Generate Link"}
              </Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify both dialogs compile</verify>
  <done>
- Remove member dialog shows confirmation
- Invite dialog supports both email and link-only modes
- Invite dialog shows success state with copyable link
- Form validation works for email input
  </done>
</task>

<task type="auto">
  <name>Task 4: Create member search hook</name>
  <files>sidekiq-webapp/src/hooks/use-member-search.ts</files>
  <action>
Create member search hook following the use-thread-search pattern:

```typescript
"use client";

import { useState, useEffect, useMemo, useCallback } from "react";
import Fuse, { type FuseResult } from "fuse.js";
import type { ReactNode } from "react";

/**
 * Member data structure for search.
 */
export interface TeamMember {
  userId: string;
  role: "owner" | "admin" | "member";
  joinedAt: Date;
  user: {
    id: string;
    name: string;
    email: string;
    image: string | null;
  };
}

/**
 * Result from the useMemberSearch hook.
 */
export interface UseMemberSearchResult {
  /** Current search query string */
  query: string;
  /** Function to update the search query */
  setQuery: (query: string) => void;
  /** Filtered members based on search query (or all members if query empty) */
  results: TeamMember[];
  /** True while debouncing (query changed but search not yet executed) */
  isSearching: boolean;
  /** Function to highlight matching text */
  highlightMatch: (text: string) => ReactNode;
}

/**
 * Hook for fuzzy searching team members by name or email.
 *
 * Features:
 * - Fuse.js fuzzy matching with typo tolerance (threshold 0.4 per CONTEXT.md)
 * - 200ms debounce for performance during typing
 * - Match highlighting for search results
 * - Returns all members when query is empty
 *
 * @example
 * ```tsx
 * const members = api.team.listMembers.useQuery({ id: teamId }).data ?? [];
 * const { query, setQuery, results, highlightMatch } = useMemberSearch(members);
 *
 * return (
 *   <div>
 *     <input value={query} onChange={(e) => setQuery(e.target.value)} />
 *     {results.map(member => (
 *       <div key={member.userId}>
 *         {highlightMatch(member.user.name)}
 *       </div>
 *     ))}
 *   </div>
 * );
 * ```
 *
 * @param members - Array of team members to search
 * @returns Search state and utilities
 */
export function useMemberSearch(members: TeamMember[]): UseMemberSearchResult {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");

  // Debounce search query (200ms)
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedQuery(query), 200);
    return () => clearTimeout(timer);
  }, [query]);

  // Create Fuse instance (memoized)
  const fuse = useMemo(
    () =>
      new Fuse(members, {
        keys: ["user.name", "user.email"],
        threshold: 0.4, // Per CONTEXT.md - matches thread search
        ignoreLocation: true,
        includeMatches: true,
      }),
    [members]
  );

  // Get search results
  const searchResults = useMemo((): FuseResult<TeamMember>[] | null => {
    if (!debouncedQuery.trim()) return null;
    return fuse.search(debouncedQuery);
  }, [fuse, debouncedQuery]);

  const results = useMemo(() => {
    if (searchResults === null) return members;
    return searchResults.map((result) => result.item);
  }, [searchResults, members]);

  // Highlight matching text
  const highlightMatch = useCallback(
    (text: string): ReactNode => {
      if (!debouncedQuery.trim() || !text) return text;

      // Find matching result
      const matchResult = searchResults?.find(
        (r) => r.item.user.name === text || r.item.user.email === text
      );

      if (!matchResult?.matches) return text;

      // Find the match for this specific text
      const match = matchResult.matches.find(
        (m) => m.value === text
      );

      if (!match?.indices) return text;

      const parts: ReactNode[] = [];
      let lastIndex = 0;

      match.indices.forEach(([start, end], i) => {
        if (start > lastIndex) {
          parts.push(text.slice(lastIndex, start));
        }
        parts.push(
          <mark key={i} className="rounded bg-yellow-500/30 px-0.5">
            {text.slice(start, end + 1)}
          </mark>
        );
        lastIndex = end + 1;
      });

      if (lastIndex < text.length) {
        parts.push(text.slice(lastIndex));
      }

      return <>{parts}</>;
    },
    [debouncedQuery, searchResults]
  );

  return {
    query,
    setQuery,
    results,
    isSearching: query !== debouncedQuery,
    highlightMatch,
  };
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify hook compiles</verify>
  <done>
- Searches both name and email fields
- Uses Fuse.js threshold 0.4 per CONTEXT.md
- 200ms debounce for performance
- Match highlighting included
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `pnpm typecheck` passes
2. All components export correctly
3. Dialogs follow established AlertDialog/Dialog patterns
4. Hook follows useThreadSearch pattern
</verification>

<success_criteria>
- TeamAvatar renders initials/emoji with colored background
- DeleteTeamDialog requires type-to-confirm
- RemoveMemberDialog shows simple confirmation
- InviteMemberDialog supports email and link-only modes
- useMemberSearch filters by name and email
</success_criteria>

<output>
After completion, create `.planning/phases/08-team-foundation/08-03-SUMMARY.md`
</output>

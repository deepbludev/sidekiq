---
phase: 03-thread-management
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
  - sidekiq-webapp/src/components/chat/chat-interface.tsx
  - sidekiq-webapp/src/server/api/routers/thread.ts
  - sidekiq-webapp/src/lib/validations/thread.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Browser tab shows thread title for existing threads on page load"
    - "Browser tab shows 'New Chat - Sidekiq' for threads without titles"
    - "Browser tab updates to auto-generated title after AI response completes"
  artifacts:
    - path: "sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx"
      provides: "generateMetadata function for SSR title"
      contains: "generateMetadata"
    - path: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      provides: "document.title update logic"
      contains: "document.title"
    - path: "sidekiq-webapp/src/server/api/routers/thread.ts"
      provides: "getTitle query for polling"
      contains: "getTitle"
  key_links:
    - from: "sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx"
      to: "ChatInterface"
      via: "title prop"
      pattern: "title.*ChatInterface|ChatInterface.*title"
    - from: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      to: "document.title"
      via: "useEffect"
      pattern: "useEffect.*document\\.title"
---

<objective>
Fix browser tab title to display thread title instead of static "Sidekiq".

Purpose: Close UAT gap - title is generated and saved but never displayed in browser tab
Output: Browser tab shows thread title via SSR and updates dynamically after title generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/debug/tab-title-not-updating.md

# Key files to modify
@sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
@sidekiq-webapp/src/components/chat/chat-interface.tsx
@sidekiq-webapp/src/server/api/routers/thread.ts
@sidekiq-webapp/src/lib/validations/thread.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generateMetadata and pass title to ChatInterface</name>
  <files>
    sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
  </files>
  <action>
Add Next.js `generateMetadata` async function for SSR title:

```typescript
import type { Metadata } from "next";

export async function generateMetadata({ params }: ThreadPageProps): Promise<Metadata> {
  const { threadId } = await params;

  const session = await getSession();
  if (!session) {
    return { title: "Sidekiq" };
  }

  const thread = await db.query.threads.findFirst({
    where: and(eq(threads.id, threadId), eq(threads.userId, session.user.id)),
    columns: { title: true },
  });

  const title = thread?.title ?? "New Chat";
  return { title: `${title} - Sidekiq` };
}
```

Note: This duplicates the thread query, but Next.js automatically deduplicates fetch/query calls within the same request. The query in the page component and generateMetadata will be deduplicated.

Update the return statement to pass title to ChatInterface:

```typescript
return (
  <ChatInterface
    threadId={thread.id}
    initialMessages={initialMessages}
    initialTitle={thread.title}
  />
);
```
  </action>
  <verify>
TypeScript compiles without errors: `cd sidekiq-webapp && npx tsc --noEmit`
  </verify>
  <done>
generateMetadata function exports dynamic title, ChatInterface receives initialTitle prop
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getTitle tRPC query and title polling to ChatInterface</name>
  <files>
    sidekiq-webapp/src/server/api/routers/thread.ts
    sidekiq-webapp/src/lib/validations/thread.ts
    sidekiq-webapp/src/components/chat/chat-interface.tsx
  </files>
  <action>
**Step 1: Add validation schema** (thread.ts validations)

Add to existing schemas:
```typescript
export const getTitleInputSchema = z.object({
  threadId: z.string().min(1),
});
```

**Step 2: Add getTitle query** (thread router)

Add new query to threadRouter:
```typescript
/**
 * Get thread title by ID.
 * Used for polling title after async generation.
 */
getTitle: protectedProcedure
  .input(getTitleInputSchema)
  .query(async ({ ctx, input }) => {
    const thread = await ctx.db.query.threads.findFirst({
      where: and(
        eq(threads.id, input.threadId),
        eq(threads.userId, ctx.session.user.id),
      ),
      columns: { title: true },
    });

    return { title: thread?.title ?? null };
  }),
```

**Step 3: Update ChatInterface** (chat-interface.tsx)

Add to interface:
```typescript
interface ChatInterfaceProps {
  threadId: string | null;
  initialMessages?: UIMessage[];
  initialTitle?: string | null;  // Add this
}
```

Add to component (near other state):
```typescript
const [currentTitle, setCurrentTitle] = useState<string | null>(initialTitle ?? null);
```

Add tRPC query with polling (after hasRedirectedRef):
```typescript
// Track the actual thread ID (may change after redirect for new threads)
const [activeThreadId, setActiveThreadId] = useState<string | null>(threadId);

// Poll for title when we have a thread but no title yet
const { data: titleData } = api.thread.getTitle.useQuery(
  { threadId: activeThreadId! },
  {
    enabled: !!activeThreadId && !currentTitle,
    refetchInterval: (query) => {
      // Poll every 2 seconds until we get a title, max 5 attempts (10 seconds)
      if (query.state.data?.title) return false;
      if (query.state.dataUpdateCount >= 5) return false;
      return 2000;
    },
  }
);
```

Update customFetch to also set activeThreadId when capturing new thread:
```typescript
if (newThreadId) {
  hasRedirectedRef.current = true;
  setActiveThreadId(newThreadId);  // Add this line
  window.history.replaceState(null, "", `/chat/${newThreadId}`);
}
```

Add useEffect for title updates:
```typescript
// Update current title when polling returns a title
useEffect(() => {
  if (titleData?.title && !currentTitle) {
    setCurrentTitle(titleData.title);
  }
}, [titleData?.title, currentTitle]);

// Update document.title when currentTitle changes
useEffect(() => {
  const displayTitle = currentTitle ?? "New Chat";
  document.title = `${displayTitle} - Sidekiq`;
}, [currentTitle]);
```

Import api at top:
```typescript
import { api } from "@sidekiq/trpc/react";
```
  </action>
  <verify>
1. TypeScript compiles: `cd sidekiq-webapp && npx tsc --noEmit`
2. Dev server starts: `cd sidekiq-webapp && npm run dev` (check no errors)
  </verify>
  <done>
- getTitle tRPC query exists and returns thread title
- ChatInterface accepts initialTitle prop
- ChatInterface updates document.title on mount and when title is fetched
- New threads poll for title after redirect, stop polling once title received
  </done>
</task>

</tasks>

<verification>
Manual verification (for UAT):
1. Navigate to existing thread with title - tab should show "{title} - Sidekiq"
2. Start new chat, send message - tab shows "New Chat - Sidekiq" initially
3. Wait for AI response to complete (~2-5 seconds) - tab updates to auto-generated title
4. Refresh page on titled thread - title persists (SSR working)

Automated verification:
- `cd sidekiq-webapp && npx tsc --noEmit` - no type errors
- `cd sidekiq-webapp && npm run lint` - no lint errors
</verification>

<success_criteria>
- Browser tab shows thread title for existing threads on initial page load (SSR)
- Browser tab shows "New Chat - Sidekiq" for untitled threads
- Browser tab updates dynamically when title is generated (polling)
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-thread-management/03-05-SUMMARY.md`
</output>

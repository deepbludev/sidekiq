---
phase: 03-thread-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidekiq-webapp/src/server/api/routers/thread.ts
  - sidekiq-webapp/src/server/api/root.ts
  - sidekiq-webapp/src/lib/validations/thread.ts
  - sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx
  - sidekiq-webapp/src/app/(dashboard)/chat/page.tsx
autonomous: true

must_haves:
  truths:
    - "Thread list query returns user's threads sorted by pinned then activity"
    - "Thread delete mutation permanently removes thread with ownership check"
    - "Thread archive mutation soft-deletes thread with ownership check"
    - "Thread pin toggle mutation works with optimistic update support"
    - "Thread rename mutation updates title with validation"
    - "/chat shows new chat state (no thread loaded)"
    - "/chat/[threadId] loads existing thread with messages"
  artifacts:
    - path: "sidekiq-webapp/src/server/api/routers/thread.ts"
      provides: "Thread tRPC router with CRUD mutations"
      exports: ["threadRouter"]
    - path: "sidekiq-webapp/src/lib/validations/thread.ts"
      provides: "Zod schemas for thread operations"
      exports: ["threadIdSchema", "threadTitleSchema", "listThreadsSchema"]
    - path: "sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx"
      provides: "Existing thread page with message loading"
  key_links:
    - from: "sidekiq-webapp/src/server/api/root.ts"
      to: "sidekiq-webapp/src/server/api/routers/thread.ts"
      via: "threadRouter import"
      pattern: "thread: threadRouter"
    - from: "sidekiq-webapp/src/server/api/routers/thread.ts"
      to: "sidekiq-webapp/src/server/db/schema.ts"
      via: "threads table import"
      pattern: "from.*schema"
---

<objective>
Create tRPC thread router with full CRUD operations and set up routing structure for /chat (new) and /chat/[threadId] (existing).

Purpose: Foundation for all thread operations used by sidebar and chat interface
Output: Thread router with list, delete, archive, pin, rename mutations; routing for new chat vs existing thread
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-thread-management/03-CONTEXT.md
@.planning/phases/03-thread-management/03-RESEARCH.md

# Key existing files to reference
@sidekiq-webapp/src/server/api/trpc.ts
@sidekiq-webapp/src/server/api/root.ts
@sidekiq-webapp/src/server/db/schema.ts
@sidekiq-webapp/src/app/(dashboard)/chat/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thread validation schemas</name>
  <files>sidekiq-webapp/src/lib/validations/thread.ts</files>
  <action>
Create Zod validation schemas for thread operations:

1. `threadIdSchema` - string ID validation
2. `threadTitleSchema` - title string with min(1), max(255)
3. `deleteThreadInput` - { threadId: string }
4. `archiveThreadInput` - { threadId: string }
5. `unarchiveThreadInput` - { threadId: string }
6. `togglePinInput` - { threadId: string }
7. `renameThreadInput` - { threadId: string, title: string }
8. `listThreadsInput` - optional { includeArchived?: boolean }

Export all schemas for use in tRPC router.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes with no type errors in thread.ts
  </verify>
  <done>
All thread validation schemas exported and type-safe
  </done>
</task>

<task type="auto">
  <name>Task 2: Create thread tRPC router with CRUD operations</name>
  <files>sidekiq-webapp/src/server/api/routers/thread.ts, sidekiq-webapp/src/server/api/root.ts</files>
  <action>
Create `src/server/api/routers/thread.ts` with protectedProcedure for all mutations:

**Queries:**
1. `list` - Return user's threads with columns: id, title, isPinned, isArchived, lastActivityAt, messageCount
   - Order by: isPinned DESC, lastActivityAt DESC (pinned first, then by activity)
   - Filter by userId from session
   - Optional includeArchived parameter (default false)

**Mutations:**
2. `delete` - Permanent deletion
   - Input: { threadId: string }
   - Verify ownership: `and(eq(threads.id, input.threadId), eq(threads.userId, ctx.session.user.id))`
   - Use `db.delete(threads).where(...).returning({ id: threads.id })`
   - Throw TRPCError NOT_FOUND if no rows affected
   - Return { success: true, deletedId: string }

3. `archive` - Soft delete (set isArchived = true)
   - Input: { threadId: string }
   - Verify ownership in WHERE clause
   - Set isArchived = true, updatedAt = new Date()
   - Return updated thread { id, isArchived }

4. `unarchive` - Restore archived thread
   - Input: { threadId: string }
   - Set isArchived = false
   - Return updated thread

5. `togglePin` - Toggle isPinned status
   - Input: { threadId: string }
   - Read current isPinned value first
   - Set isPinned = !current, updatedAt = new Date()
   - Return { id, isPinned }

6. `rename` - Update thread title
   - Input: { threadId: string, title: string }
   - Use threadTitleSchema for validation
   - Verify ownership
   - Return { id, title }

Then register in root.ts: `thread: threadRouter`

All mutations MUST include userId check in WHERE clause for security.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `pnpm lint` passes
  </verify>
  <done>
Thread router registered in appRouter with all 6 procedures (1 query, 5 mutations) and proper ownership checks
  </done>
</task>

<task type="auto">
  <name>Task 3: Set up /chat and /chat/[threadId] routing</name>
  <files>sidekiq-webapp/src/app/(dashboard)/chat/page.tsx, sidekiq-webapp/src/app/(dashboard)/chat/[threadId]/page.tsx</files>
  <action>
**Update /chat/page.tsx (new chat state):**
- Remove the "find or create default thread" logic
- This page represents the "new chat" state
- No thread is loaded - pass threadId={null} to ChatInterface
- Server component still needs auth check, redirect to /sign-in if not authenticated
- Comment indicating thread will be created on first message send

**Create /chat/[threadId]/page.tsx (existing thread):**
- Server component with dynamic route params
- Get threadId from params (params is Promise in Next.js 15 app router)
- Auth check - redirect to /sign-in if not authenticated
- Load thread from database with ownership check: `eq(threads.id, threadId)` AND `eq(threads.userId, session.user.id)`
- If thread not found or doesn't belong to user, redirect to /chat
- Load messages for the thread using Drizzle relations or separate query
- If thread.isArchived is true, still load it (archived threads can be viewed)
- Pass threadId and initialMessages to ChatInterface

**Import patterns:**
- Use `import { db } from "@sidekiq/server/db"` for database
- Use `import { threads, messages } from "@sidekiq/server/db/schema"` for tables
- Use `import { getSession } from "@sidekiq/server/better-auth/server"` for auth
- Use `import { redirect } from "next/navigation"` for redirects
  </action>
  <verify>
1. Navigate to /chat - page loads without errors (empty new chat state)
2. Navigate to /chat/nonexistent-id - redirects to /chat
3. `pnpm exec tsc --noEmit` passes
  </verify>
  <done>
Two distinct routes: /chat (new chat) and /chat/[threadId] (existing thread with messages)
  </done>
</task>

</tasks>

<verification>
1. Thread router is registered and accessible via tRPC client
2. All mutations require authentication (protectedProcedure)
3. All mutations verify thread ownership before modifying
4. /chat page shows new chat state
5. /chat/[threadId] loads thread with messages from database
6. TypeScript compiles without errors
</verification>

<success_criteria>
- Thread tRPC router exported with list, delete, archive, unarchive, togglePin, rename procedures
- Validation schemas exported from lib/validations/thread.ts
- /chat renders ChatInterface with threadId={null}
- /chat/[threadId] renders ChatInterface with threadId and initialMessages
- All ownership checks use AND clause with userId from session
</success_criteria>

<output>
After completion, create `.planning/phases/03-thread-management/03-01-SUMMARY.md`
</output>

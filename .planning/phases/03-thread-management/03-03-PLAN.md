---
phase: 03-thread-management
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - sidekiq-webapp/src/components/ui/context-menu.tsx
  - sidekiq-webapp/src/components/ui/alert-dialog.tsx
  - sidekiq-webapp/src/components/thread/thread-item.tsx
  - sidekiq-webapp/src/components/thread/thread-context-menu.tsx
  - sidekiq-webapp/src/components/thread/delete-thread-dialog.tsx
  - sidekiq-webapp/src/components/thread/rename-thread-input.tsx
  - sidekiq-webapp/src/hooks/use-thread-actions.ts
autonomous: true

must_haves:
  truths:
    - "Thread item shows title, hover reveals action icons (pin, archive, more)"
    - "Right-click on thread opens context menu with actions"
    - "Delete action shows confirmation dialog before permanent deletion"
    - "Archive action happens immediately with toast and undo option"
    - "Pin toggle works with optimistic UI update"
    - "Rename allows inline editing by clicking on title"
    - "After deleting active thread, navigates to /chat"
  artifacts:
    - path: "sidekiq-webapp/src/components/thread/thread-item.tsx"
      provides: "Thread item with hover actions and context menu trigger"
    - path: "sidekiq-webapp/src/components/thread/delete-thread-dialog.tsx"
      provides: "Confirmation dialog for thread deletion"
    - path: "sidekiq-webapp/src/hooks/use-thread-actions.ts"
      provides: "Custom hook with tRPC mutations for thread actions"
      exports: ["useThreadActions"]
  key_links:
    - from: "sidekiq-webapp/src/hooks/use-thread-actions.ts"
      to: "sidekiq-webapp/src/server/api/routers/thread.ts"
      via: "tRPC client mutations"
      pattern: "api\\.thread\\."
    - from: "sidekiq-webapp/src/components/thread/thread-item.tsx"
      to: "sidekiq-webapp/src/hooks/use-thread-actions.ts"
      via: "useThreadActions hook"
      pattern: "useThreadActions"
---

<objective>
Create thread action UI components: thread item with hover icons, context menu, delete dialog, and inline rename.

Purpose: Enable users to manage threads via intuitive UI interactions
Output: Reusable thread components ready for sidebar integration in Phase 5
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-thread-management/03-CONTEXT.md
@.planning/phases/03-thread-management/03-RESEARCH.md
@.planning/phases/03-thread-management/03-01-SUMMARY.md

# Key existing files to reference
@sidekiq-webapp/src/server/api/routers/thread.ts
@sidekiq-webapp/src/components/ui/dropdown-menu.tsx
@sidekiq-webapp/src/components/ui/dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn/ui context-menu and alert-dialog components</name>
  <files>sidekiq-webapp/src/components/ui/context-menu.tsx, sidekiq-webapp/src/components/ui/alert-dialog.tsx</files>
  <action>
Install required shadcn/ui components:

```bash
cd sidekiq-webapp && pnpm dlx shadcn@latest add context-menu alert-dialog
```

This will create:
- `src/components/ui/context-menu.tsx` - Right-click context menu
- `src/components/ui/alert-dialog.tsx` - Confirmation dialog

Both use Radix primitives with consistent styling from project's design system.
  </action>
  <verify>
1. Files exist at expected paths
2. `pnpm exec tsc --noEmit` passes
  </verify>
  <done>
context-menu and alert-dialog components installed in components/ui/
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useThreadActions hook with tRPC mutations</name>
  <files>sidekiq-webapp/src/hooks/use-thread-actions.ts</files>
  <action>
Create custom hook that wraps all thread tRPC mutations with optimistic updates:

```typescript
"use client";

import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { api } from "@sidekiq/trpc/react";

interface UseThreadActionsProps {
  /** Currently active thread ID (for redirect after delete) */
  activeThreadId?: string | null;
}

/**
 * Hook providing thread action mutations with optimistic updates.
 *
 * Includes: delete, archive, unarchive, togglePin, rename
 * Handles cache invalidation and error rollback.
 */
export function useThreadActions({ activeThreadId }: UseThreadActionsProps = {}) {
  const router = useRouter();
  const utils = api.useUtils();

  // Delete mutation - requires confirmation dialog
  const deleteMutation = api.thread.delete.useMutation({
    onSuccess: (data) => {
      // If deleted active thread, navigate to new chat
      if (data.deletedId === activeThreadId) {
        router.push("/chat");
      }
    },
    onError: (error) => {
      toast.error("Failed to delete conversation", {
        description: error.message,
      });
    },
    onSettled: () => {
      utils.thread.list.invalidate();
    },
  });

  // Archive mutation with toast and undo
  const archiveMutation = api.thread.archive.useMutation({
    onMutate: async ({ threadId }) => {
      await utils.thread.list.cancel();
      const previousThreads = utils.thread.list.getData();

      // Optimistic update - hide from list
      utils.thread.list.setData(undefined, (old) =>
        old?.map((t) =>
          t.id === threadId ? { ...t, isArchived: true } : t
        )
      );

      return { previousThreads };
    },
    onSuccess: (data) => {
      toast.success("Conversation archived", {
        action: {
          label: "Undo",
          onClick: () => unarchiveMutation.mutate({ threadId: data.id }),
        },
        duration: 5000,
      });

      // If archived active thread, navigate to new chat
      if (data.id === activeThreadId) {
        router.push("/chat");
      }
    },
    onError: (error, variables, context) => {
      // Rollback optimistic update
      if (context?.previousThreads) {
        utils.thread.list.setData(undefined, context.previousThreads);
      }
      toast.error("Failed to archive conversation", {
        description: error.message,
      });
    },
    onSettled: () => {
      utils.thread.list.invalidate();
    },
  });

  // Unarchive mutation
  const unarchiveMutation = api.thread.unarchive.useMutation({
    onMutate: async ({ threadId }) => {
      await utils.thread.list.cancel();
      const previousThreads = utils.thread.list.getData();

      utils.thread.list.setData(undefined, (old) =>
        old?.map((t) =>
          t.id === threadId ? { ...t, isArchived: false } : t
        )
      );

      return { previousThreads };
    },
    onError: (error, variables, context) => {
      if (context?.previousThreads) {
        utils.thread.list.setData(undefined, context.previousThreads);
      }
      toast.error("Failed to restore conversation", {
        description: error.message,
      });
    },
    onSettled: () => {
      utils.thread.list.invalidate();
    },
  });

  // Toggle pin mutation with optimistic update
  const togglePinMutation = api.thread.togglePin.useMutation({
    onMutate: async ({ threadId }) => {
      await utils.thread.list.cancel();
      const previousThreads = utils.thread.list.getData();

      utils.thread.list.setData(undefined, (old) =>
        old?.map((t) =>
          t.id === threadId ? { ...t, isPinned: !t.isPinned } : t
        )
      );

      return { previousThreads };
    },
    onError: (error, variables, context) => {
      if (context?.previousThreads) {
        utils.thread.list.setData(undefined, context.previousThreads);
      }
      toast.error("Failed to update pin status", {
        description: error.message,
      });
    },
    onSettled: () => {
      utils.thread.list.invalidate();
    },
  });

  // Rename mutation
  const renameMutation = api.thread.rename.useMutation({
    onMutate: async ({ threadId, title }) => {
      await utils.thread.list.cancel();
      const previousThreads = utils.thread.list.getData();

      utils.thread.list.setData(undefined, (old) =>
        old?.map((t) =>
          t.id === threadId ? { ...t, title } : t
        )
      );

      return { previousThreads };
    },
    onError: (error, variables, context) => {
      if (context?.previousThreads) {
        utils.thread.list.setData(undefined, context.previousThreads);
      }
      toast.error("Failed to rename conversation", {
        description: error.message,
      });
    },
    onSettled: () => {
      utils.thread.list.invalidate();
    },
  });

  return {
    deleteThread: deleteMutation.mutate,
    archiveThread: archiveMutation.mutate,
    unarchiveThread: unarchiveMutation.mutate,
    togglePin: togglePinMutation.mutate,
    renameThread: renameMutation.mutate,
    isDeleting: deleteMutation.isPending,
    isArchiving: archiveMutation.isPending,
    isRenaming: renameMutation.isPending,
  };
}
```
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes with no errors in use-thread-actions.ts
  </verify>
  <done>
useThreadActions hook provides all mutations with optimistic updates and toast feedback
  </done>
</task>

<task type="auto">
  <name>Task 3: Create thread action UI components</name>
  <files>
    sidekiq-webapp/src/components/thread/thread-item.tsx,
    sidekiq-webapp/src/components/thread/thread-context-menu.tsx,
    sidekiq-webapp/src/components/thread/delete-thread-dialog.tsx,
    sidekiq-webapp/src/components/thread/rename-thread-input.tsx
  </files>
  <action>
Create component directory and files at `src/components/thread/`:

**1. delete-thread-dialog.tsx:**
```typescript
"use client";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@sidekiq/components/ui/alert-dialog";

interface DeleteThreadDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  threadTitle: string | null;
  isDeleting?: boolean;
}

/**
 * Confirmation dialog for permanent thread deletion.
 * Explains archive as recoverable alternative.
 */
export function DeleteThreadDialog({
  open,
  onOpenChange,
  onConfirm,
  threadTitle,
  isDeleting = false,
}: DeleteThreadDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete conversation?</AlertDialogTitle>
          <AlertDialogDescription>
            This will permanently delete "{threadTitle || 'this conversation'}".
            This action cannot be undone.
            <br /><br />
            If you want to hide it temporarily, consider archiving instead.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting ? "Deleting..." : "Delete"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

**2. rename-thread-input.tsx:**
```typescript
"use client";

import { useState, useRef, useEffect, type KeyboardEvent } from "react";
import { cn } from "@sidekiq/lib/utils";

interface RenameThreadInputProps {
  initialTitle: string | null;
  onRename: (title: string) => void;
  onCancel: () => void;
  className?: string;
}

/**
 * Inline input for renaming thread title.
 * Auto-focuses and selects text on mount.
 */
export function RenameThreadInput({
  initialTitle,
  onRename,
  onCancel,
  className,
}: RenameThreadInputProps) {
  const [value, setValue] = useState(initialTitle || "");
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
    inputRef.current?.select();
  }, []);

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      const trimmed = value.trim();
      if (trimmed && trimmed !== initialTitle) {
        onRename(trimmed);
      } else {
        onCancel();
      }
    } else if (e.key === "Escape") {
      onCancel();
    }
  };

  const handleBlur = () => {
    const trimmed = value.trim();
    if (trimmed && trimmed !== initialTitle) {
      onRename(trimmed);
    } else {
      onCancel();
    }
  };

  return (
    <input
      ref={inputRef}
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
      onKeyDown={handleKeyDown}
      onBlur={handleBlur}
      className={cn(
        "w-full rounded px-1 py-0.5 text-sm",
        "bg-background border border-input",
        "focus:outline-none focus:ring-2 focus:ring-ring",
        className
      )}
      maxLength={255}
    />
  );
}
```

**3. thread-context-menu.tsx:**
```typescript
"use client";

import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuSeparator,
  ContextMenuTrigger,
} from "@sidekiq/components/ui/context-menu";
import { Pin, PinOff, Archive, ArchiveRestore, Pencil, Trash2, RefreshCw } from "lucide-react";

interface ThreadContextMenuProps {
  children: React.ReactNode;
  isPinned: boolean;
  isArchived: boolean;
  onTogglePin: () => void;
  onArchive: () => void;
  onUnarchive: () => void;
  onRename: () => void;
  onDelete: () => void;
  onRegenerateTitle?: () => void;
}

/**
 * Right-click context menu for thread actions.
 */
export function ThreadContextMenu({
  children,
  isPinned,
  isArchived,
  onTogglePin,
  onArchive,
  onUnarchive,
  onRename,
  onDelete,
  onRegenerateTitle,
}: ThreadContextMenuProps) {
  return (
    <ContextMenu>
      <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>
      <ContextMenuContent className="w-48">
        <ContextMenuItem onClick={onTogglePin}>
          {isPinned ? (
            <>
              <PinOff className="mr-2 h-4 w-4" />
              Unpin
            </>
          ) : (
            <>
              <Pin className="mr-2 h-4 w-4" />
              Pin
            </>
          )}
        </ContextMenuItem>
        <ContextMenuItem onClick={onRename}>
          <Pencil className="mr-2 h-4 w-4" />
          Rename
        </ContextMenuItem>
        {onRegenerateTitle && (
          <ContextMenuItem onClick={onRegenerateTitle}>
            <RefreshCw className="mr-2 h-4 w-4" />
            Regenerate title
          </ContextMenuItem>
        )}
        <ContextMenuSeparator />
        {isArchived ? (
          <ContextMenuItem onClick={onUnarchive}>
            <ArchiveRestore className="mr-2 h-4 w-4" />
            Restore
          </ContextMenuItem>
        ) : (
          <ContextMenuItem onClick={onArchive}>
            <Archive className="mr-2 h-4 w-4" />
            Archive
          </ContextMenuItem>
        )}
        <ContextMenuSeparator />
        <ContextMenuItem
          onClick={onDelete}
          className="text-destructive focus:text-destructive"
        >
          <Trash2 className="mr-2 h-4 w-4" />
          Delete
        </ContextMenuItem>
      </ContextMenuContent>
    </ContextMenu>
  );
}
```

**4. thread-item.tsx:**
```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Pin, Archive, MoreHorizontal } from "lucide-react";
import { cn } from "@sidekiq/lib/utils";
import { ThreadContextMenu } from "./thread-context-menu";
import { DeleteThreadDialog } from "./delete-thread-dialog";
import { RenameThreadInput } from "./rename-thread-input";
import { useThreadActions } from "@sidekiq/hooks/use-thread-actions";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@sidekiq/components/ui/dropdown-menu";
import { Button } from "@sidekiq/components/ui/button";

interface Thread {
  id: string;
  title: string | null;
  isPinned: boolean;
  isArchived: boolean;
  lastActivityAt: Date;
  messageCount: number;
}

interface ThreadItemProps {
  thread: Thread;
  isActive: boolean;
  activeThreadId?: string | null;
}

/**
 * Thread list item with hover actions and context menu.
 *
 * Displays thread title, pin/archive indicators.
 * Shows action buttons on hover, supports right-click menu.
 */
export function ThreadItem({ thread, isActive, activeThreadId }: ThreadItemProps) {
  const router = useRouter();
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);

  const {
    deleteThread,
    archiveThread,
    unarchiveThread,
    togglePin,
    renameThread,
    isDeleting,
  } = useThreadActions({ activeThreadId });

  const handleClick = () => {
    if (!isRenaming) {
      router.push(`/chat/${thread.id}`);
    }
  };

  const handleRename = (newTitle: string) => {
    renameThread({ threadId: thread.id, title: newTitle });
    setIsRenaming(false);
  };

  const handleDelete = () => {
    deleteThread({ threadId: thread.id });
    setShowDeleteDialog(false);
  };

  return (
    <>
      <ThreadContextMenu
        isPinned={thread.isPinned}
        isArchived={thread.isArchived}
        onTogglePin={() => togglePin({ threadId: thread.id })}
        onArchive={() => archiveThread({ threadId: thread.id })}
        onUnarchive={() => unarchiveThread({ threadId: thread.id })}
        onRename={() => setIsRenaming(true)}
        onDelete={() => setShowDeleteDialog(true)}
      >
        <div
          role="button"
          tabIndex={0}
          onClick={handleClick}
          onKeyDown={(e) => e.key === "Enter" && handleClick()}
          className={cn(
            "group flex items-center gap-2 rounded-lg px-3 py-2",
            "cursor-pointer transition-colors",
            "hover:bg-accent/50",
            isActive && "bg-accent",
            thread.isArchived && "opacity-60"
          )}
        >
          {/* Pin indicator */}
          {thread.isPinned && (
            <Pin className="h-3 w-3 shrink-0 text-muted-foreground" />
          )}

          {/* Title or rename input */}
          <div className="flex-1 truncate">
            {isRenaming ? (
              <RenameThreadInput
                initialTitle={thread.title}
                onRename={handleRename}
                onCancel={() => setIsRenaming(false)}
              />
            ) : (
              <span className="text-sm">
                {thread.title || "New conversation"}
              </span>
            )}
          </div>

          {/* Archive indicator */}
          {thread.isArchived && (
            <Archive className="h-3 w-3 shrink-0 text-muted-foreground" />
          )}

          {/* Hover actions - only show when not renaming */}
          {!isRenaming && (
            <div className={cn(
              "flex items-center gap-1",
              "opacity-0 group-hover:opacity-100 transition-opacity"
            )}>
              {/* Quick pin toggle */}
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6"
                onClick={(e) => {
                  e.stopPropagation();
                  togglePin({ threadId: thread.id });
                }}
              >
                {thread.isPinned ? (
                  <Pin className="h-3 w-3 fill-current" />
                ) : (
                  <Pin className="h-3 w-3" />
                )}
              </Button>

              {/* More actions dropdown */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-6 w-6"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreHorizontal className="h-3 w-3" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-40">
                  <DropdownMenuItem onClick={() => setIsRenaming(true)}>
                    Rename
                  </DropdownMenuItem>
                  {thread.isArchived ? (
                    <DropdownMenuItem
                      onClick={() => unarchiveThread({ threadId: thread.id })}
                    >
                      Restore
                    </DropdownMenuItem>
                  ) : (
                    <DropdownMenuItem
                      onClick={() => archiveThread({ threadId: thread.id })}
                    >
                      Archive
                    </DropdownMenuItem>
                  )}
                  <DropdownMenuSeparator />
                  <DropdownMenuItem
                    onClick={() => setShowDeleteDialog(true)}
                    className="text-destructive focus:text-destructive"
                  >
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          )}
        </div>
      </ThreadContextMenu>

      <DeleteThreadDialog
        open={showDeleteDialog}
        onOpenChange={setShowDeleteDialog}
        onConfirm={handleDelete}
        threadTitle={thread.title}
        isDeleting={isDeleting}
      />
    </>
  );
}
```

Create barrel export file `src/components/thread/index.ts`:
```typescript
export { ThreadItem } from "./thread-item";
export { ThreadContextMenu } from "./thread-context-menu";
export { DeleteThreadDialog } from "./delete-thread-dialog";
export { RenameThreadInput } from "./rename-thread-input";
```
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `pnpm lint` passes
3. All components compile without errors
  </verify>
  <done>
All thread action components created: ThreadItem with hover actions, context menu, delete dialog, rename input
  </done>
</task>

</tasks>

<verification>
1. shadcn/ui context-menu and alert-dialog components installed
2. useThreadActions hook provides all mutations with optimistic updates
3. ThreadItem renders with hover action buttons
4. Right-click opens context menu with all thread actions
5. Delete shows confirmation dialog before execution
6. Archive shows toast with undo action
7. Pin toggle updates immediately (optimistic)
8. Rename shows inline input on click
9. TypeScript compiles without errors
</verification>

<success_criteria>
- context-menu and alert-dialog from shadcn/ui installed and working
- useThreadActions hook exports all mutations with proper cache handling
- ThreadItem shows title with pin/archive indicators
- Hover reveals quick action buttons
- Context menu provides full action list
- Delete requires confirmation dialog
- Archive shows toast with undo (5 second window)
- Rename via inline input with Enter/Escape/Blur handling
- All components follow glassmorphism styling
</success_criteria>

<output>
After completion, create `.planning/phases/03-thread-management/03-03-SUMMARY.md`
</output>

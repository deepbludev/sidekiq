---
phase: 03-thread-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - sidekiq-webapp/src/app/api/chat/route.ts
  - sidekiq-webapp/src/lib/ai/title.ts
  - sidekiq-webapp/src/lib/validations/chat.ts
  - sidekiq-webapp/src/components/chat/chat-interface.tsx
autonomous: true

must_haves:
  truths:
    - "Thread is created atomically when first message is sent from new chat state"
    - "New thread redirects to /chat/[threadId] after creation"
    - "Auto-title is generated after first AI response completes (not blocking)"
    - "Title generation uses budget model (gpt-4o-mini) regardless of thread model"
    - "Title fallback to 'New conversation' on generation failure"
    - "Archived threads auto-unarchive when receiving new message"
  artifacts:
    - path: "sidekiq-webapp/src/lib/ai/title.ts"
      provides: "Title generation function using generateText"
      exports: ["generateThreadTitle"]
    - path: "sidekiq-webapp/src/app/api/chat/route.ts"
      provides: "Updated chat route with thread creation and auto-title"
  key_links:
    - from: "sidekiq-webapp/src/app/api/chat/route.ts"
      to: "sidekiq-webapp/src/lib/ai/title.ts"
      via: "generateThreadTitle import"
      pattern: "generateThreadTitle"
    - from: "sidekiq-webapp/src/app/api/chat/route.ts"
      to: "sidekiq-webapp/src/server/db/schema.ts"
      via: "thread insert/update"
      pattern: "db\\.insert\\(threads\\)"
---

<objective>
Implement thread creation on first message and auto-title generation after first AI response.

Purpose: Enable creating threads from new chat state and generating meaningful titles automatically
Output: Modified /api/chat with thread creation logic, title generation function, updated ChatInterface
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-thread-management/03-CONTEXT.md
@.planning/phases/03-thread-management/03-RESEARCH.md
@.planning/phases/03-thread-management/03-01-SUMMARY.md

# Key existing files to reference
@sidekiq-webapp/src/app/api/chat/route.ts
@sidekiq-webapp/src/components/chat/chat-interface.tsx
@sidekiq-webapp/src/lib/ai/models.ts
@sidekiq-webapp/src/lib/ai/gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create title generation function</name>
  <files>sidekiq-webapp/src/lib/ai/title.ts</files>
  <action>
Create `src/lib/ai/title.ts` with generateThreadTitle function:

```typescript
import { generateText } from "ai";
import { getModel } from "@sidekiq/lib/ai/models";

/** Budget model for title generation - fast and cheap */
const TITLE_MODEL = "openai/gpt-4o-mini";

/** Fallback title when generation fails */
const FALLBACK_TITLE = "New conversation";

/**
 * Generate a concise title for a conversation thread.
 *
 * Uses a budget model regardless of the thread's active model.
 * Returns a fallback title if generation fails.
 *
 * @param userMessage - First user message content
 * @param assistantMessage - First AI response content
 * @returns Promise<string> - 3-6 word title
 */
export async function generateThreadTitle(
  userMessage: string,
  assistantMessage: string
): Promise<string> {
  try {
    const { text } = await generateText({
      model: getModel(TITLE_MODEL),
      prompt: `Generate a concise title (3-6 words) for this conversation.
Extract the key topic only. No quotes, no punctuation at end.
Do not start with "Help with" or similar phrases.

User: ${userMessage.slice(0, 500)}
Assistant: ${assistantMessage.slice(0, 500)}

Title:`,
      maxTokens: 20,
    });

    // Clean up: remove quotes, trim, limit length
    const cleanTitle = text
      .trim()
      .replace(/^["']|["']$/g, "")
      .replace(/[.!?]$/, "")
      .slice(0, 100);

    return cleanTitle || FALLBACK_TITLE;
  } catch (error) {
    console.error("[Title Generation] Failed:", error);
    return FALLBACK_TITLE;
  }
}
```

Export function for use in chat route.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes with no errors in title.ts
  </verify>
  <done>
generateThreadTitle function exported, handles errors gracefully with fallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Update chat route for thread creation and auto-title</name>
  <files>sidekiq-webapp/src/app/api/chat/route.ts, sidekiq-webapp/src/lib/validations/chat.ts</files>
  <action>
**Update chat.ts validation schema:**
- Make threadId optional: `threadId: z.string().optional()` (or use `z.string().nullish()`)
- Thread can be null/undefined for new chat state

**Update route.ts with thread creation logic:**

1. **Handle thread creation when threadId is missing:**
   ```typescript
   let thread = null;
   let isNewThread = false;

   if (threadId) {
     // Existing thread - verify ownership (existing logic)
     thread = await db.query.threads.findFirst({
       where: eq(threads.id, threadId),
     });
     if (!thread) return Response 404;
     if (thread.userId !== session.user.id) return Response 403;
   } else {
     // New thread - create atomically with first message
     isNewThread = true;
     const newThreadId = nanoid();
     [thread] = await db
       .insert(threads)
       .values({
         id: newThreadId,
         userId: session.user.id,
         title: null, // Will be set after first AI response
         lastActivityAt: new Date(),
       })
       .returning();
   }
   ```

2. **Handle archived thread auto-unarchive:**
   ```typescript
   if (thread.isArchived) {
     await db
       .update(threads)
       .set({ isArchived: false, updatedAt: new Date() })
       .where(eq(threads.id, thread.id));
   }
   ```

3. **Include thread ID in response for new threads:**
   - Return threadId in streaming response metadata or headers
   - Use custom header: `X-Thread-Id: ${thread.id}` when isNewThread
   - This allows frontend to redirect to /chat/[threadId]

4. **Generate title after first AI response (in onFinish):**
   ```typescript
   onFinish: async ({ responseMessage, ... }) => {
     // ... existing message persistence logic ...

     // Generate title for new threads (fire-and-forget)
     if (isNewThread) {
       const userContent = extractTextContent(userMessage as UIMessage);
       const assistantContent = extractTextContent(responseMessage);

       // Don't await - let it happen async
       generateThreadTitle(userContent, assistantContent)
         .then(async (title) => {
           await db
             .update(threads)
             .set({ title, updatedAt: new Date() })
             .where(eq(threads.id, thread.id));
         })
         .catch((err) => {
           console.error("[Auto-title] Failed:", err);
         });
     }
   }
   ```

**Import generateThreadTitle from lib/ai/title.ts**
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` passes
2. `pnpm lint` passes
  </verify>
  <done>
Chat route creates thread on first message, returns thread ID, generates title async after response
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ChatInterface to handle new chat state and redirect</name>
  <files>sidekiq-webapp/src/components/chat/chat-interface.tsx</files>
  <action>
Update ChatInterface to:

1. **Accept nullable threadId:**
   ```typescript
   interface ChatInterfaceProps {
     threadId: string | null;
     initialMessages?: UIMessage[];
   }
   ```

2. **Handle thread creation response:**
   - Listen for X-Thread-Id header in response
   - When received, redirect to /chat/[newThreadId]
   - Use `useRouter` from 'next/navigation' for client-side navigation

   ```typescript
   import { useRouter } from "next/navigation";

   // In component:
   const router = useRouter();

   // Create transport with custom fetch to capture thread ID
   const transport = new DefaultChatTransport({
     api: "/api/chat",
     body: threadId ? { threadId } : {},
     fetch: async (input, init) => {
       const response = await fetch(input, init);

       // Check for new thread ID header
       const newThreadId = response.headers.get("X-Thread-Id");
       if (newThreadId && !threadId) {
         // Replace current URL so back button goes to /chat, not nowhere
         router.replace(`/chat/${newThreadId}`);
       }

       return response;
     },
   });
   ```

3. **Handle empty threadId in body:**
   - Only include threadId in body if it's not null
   - API will create thread when threadId is missing

4. **Ensure initialMessages works for both states:**
   - New chat: empty array (default)
   - Existing thread: messages from database
  </action>
  <verify>
1. From /chat, send a message - verify redirect to /chat/[threadId] happens
2. From /chat/[threadId], send a message - verify no redirect, normal flow
3. Check database for new thread with auto-generated title (may take a moment)
  </verify>
  <done>
ChatInterface handles both new and existing chat states, redirects after thread creation
  </done>
</task>

</tasks>

<verification>
1. From /chat, sending first message creates thread and redirects to /chat/[threadId]
2. Thread title is auto-generated after first AI response completes
3. Title is 3-6 words, summarizing the conversation topic
4. Sending message to archived thread auto-unarchives it
5. TypeScript compiles without errors
6. No blocking of response for title generation (async/fire-and-forget)
</verification>

<success_criteria>
- New chat (/chat) creates thread on first message send
- Frontend redirects to /chat/[threadId] after thread creation
- Title generated using gpt-4o-mini model (budget)
- Title generation failures fallback to "New conversation"
- Archived threads auto-unarchive when new message sent
- All operations complete without blocking the streaming response
</success_criteria>

<output>
After completion, create `.planning/phases/03-thread-management/03-02-SUMMARY.md`
</output>

---
phase: 04-model-selection
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - sidekiq-webapp/src/components/chat/chat-interface.tsx
  - sidekiq-webapp/src/components/chat/chat-input.tsx
  - sidekiq-webapp/src/components/chat/model-switch-hint.tsx
  - sidekiq-webapp/src/server/api/routers/user.ts
  - sidekiq-webapp/src/server/api/root.ts
  - sidekiq-webapp/src/lib/validations/user.ts
  - sidekiq-webapp/src/app/api/chat/route.ts
  - sidekiq-webapp/src/hooks/use-model-selection.ts
autonomous: true

must_haves:
  truths:
    - "User sees model picker below chat input"
    - "Selected model is sent with each message"
    - "Thread activeModel is updated when model changes"
    - "User can favorite models and favorites persist across sessions"
    - "User can set a default model"
    - "Model switch shows inline hint in chat"
  artifacts:
    - path: "sidekiq-webapp/src/components/chat/chat-interface.tsx"
      provides: "ChatInterface with ModelPicker integration"
      contains: "ModelPicker"
    - path: "sidekiq-webapp/src/server/api/routers/user.ts"
      provides: "User preferences tRPC router"
      exports: ["userRouter"]
    - path: "sidekiq-webapp/src/hooks/use-model-selection.ts"
      provides: "Hook managing model selection state and persistence"
      exports: ["useModelSelection"]
    - path: "sidekiq-webapp/src/components/chat/model-switch-hint.tsx"
      provides: "Inline hint component for model switches"
      contains: "Separator"
  key_links:
    - from: "chat-interface.tsx"
      to: "use-model-selection.ts"
      via: "useModelSelection hook"
      pattern: "useModelSelection"
    - from: "chat-interface.tsx"
      to: "model-picker"
      via: "ModelPicker component"
      pattern: "<ModelPicker"
    - from: "use-model-selection.ts"
      to: "user router"
      via: "tRPC mutations"
      pattern: "api\\.user\\."
    - from: "chat/route.ts"
      to: "threads table"
      via: "activeModel update"
      pattern: "activeModel.*modelId"
---

<objective>
Wire model picker into the chat interface with full persistence and user preferences.

Purpose: Complete the model selection feature by integrating the picker component, adding user preferences backend, and ensuring model selection persists correctly per thread and per user.

Output:
- Model picker appears below chat input, bottom-right
- Selected model sent with messages via body.model
- Thread activeModel updated on each message
- User preferences tRPC router for favorites/default
- Model switch inline hint when model changes mid-conversation
- useModelSelection hook managing all state
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/agents/gsd-planner.md (for must_haves reference)
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-model-selection/04-CONTEXT.md
@.planning/phases/04-model-selection/04-RESEARCH.md
@.planning/phases/04-model-selection/04-01-SUMMARY.md
@.planning/phases/04-model-selection/04-02-SUMMARY.md

Key existing files:
@sidekiq-webapp/src/components/chat/chat-interface.tsx
@sidekiq-webapp/src/components/chat/chat-input.tsx
@sidekiq-webapp/src/app/api/chat/route.ts
@sidekiq-webapp/src/server/api/root.ts
@sidekiq-webapp/src/server/db/schema.ts (user.preferences)
@sidekiq-webapp/src/components/model-picker/index.ts (from 04-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user preferences tRPC router</name>
  <files>
    sidekiq-webapp/src/server/api/routers/user.ts
    sidekiq-webapp/src/server/api/root.ts
    sidekiq-webapp/src/lib/validations/user.ts
  </files>
  <action>
Create user preferences router for favorites and default model.

**1. Create validation schemas** (sidekiq-webapp/src/lib/validations/user.ts):
```typescript
import { z } from "zod";

/**
 * Schema for updating user model preferences.
 */
export const updateModelPreferencesSchema = z.object({
  /** Set as user's default model for new threads */
  defaultModel: z.string().optional(),
  /** Toggle a model's favorite status */
  toggleFavorite: z.string().optional(),
});

export type UpdateModelPreferencesInput = z.infer<typeof updateModelPreferencesSchema>;

/**
 * Schema for getting user preferences.
 */
export const getPreferencesSchema = z.object({}).optional();
```

**2. Create user router** (sidekiq-webapp/src/server/api/routers/user.ts):
```typescript
import { eq } from "drizzle-orm";

import { createTRPCRouter, protectedProcedure } from "@sidekiq/server/api/trpc";
import { user, type UserPreferences } from "@sidekiq/server/db/schema";
import { updateModelPreferencesSchema } from "@sidekiq/lib/validations/user";

/**
 * User router - User preferences and settings.
 */
export const userRouter = createTRPCRouter({
  /**
   * Get current user's preferences.
   */
  getPreferences: protectedProcedure.query(async ({ ctx }) => {
    const result = await ctx.db.query.user.findFirst({
      where: eq(user.id, ctx.session.user.id),
      columns: { preferences: true },
    });

    return (result?.preferences ?? {}) as UserPreferences;
  }),

  /**
   * Update model preferences (default model, favorites).
   */
  updateModelPreferences: protectedProcedure
    .input(updateModelPreferencesSchema)
    .mutation(async ({ ctx, input }) => {
      // Get current preferences
      const current = await ctx.db.query.user.findFirst({
        where: eq(user.id, ctx.session.user.id),
        columns: { preferences: true },
      });

      const currentPrefs = (current?.preferences ?? {}) as UserPreferences;
      const updatedPrefs: UserPreferences = { ...currentPrefs };

      // Update default model if provided
      if (input.defaultModel !== undefined) {
        updatedPrefs.defaultModel = input.defaultModel;
      }

      // Toggle favorite if provided
      if (input.toggleFavorite !== undefined) {
        const favorites = updatedPrefs.favoriteModels ?? [];
        const modelId = input.toggleFavorite;

        if (favorites.includes(modelId)) {
          updatedPrefs.favoriteModels = favorites.filter((id) => id !== modelId);
        } else {
          updatedPrefs.favoriteModels = [...favorites, modelId];
        }
      }

      // Save updated preferences
      await ctx.db
        .update(user)
        .set({ preferences: updatedPrefs, updatedAt: new Date() })
        .where(eq(user.id, ctx.session.user.id));

      return updatedPrefs;
    }),
});
```

**3. Add user router to root** (sidekiq-webapp/src/server/api/root.ts):
Import and add the user router to the appRouter:
```typescript
import { userRouter } from "./routers/user";

export const appRouter = createTRPCRouter({
  health: healthRouter,
  thread: threadRouter,
  user: userRouter,  // Add this line
});
```
  </action>
  <verify>
- Router file exists: `ls sidekiq-webapp/src/server/api/routers/user.ts`
- Validation file exists: `ls sidekiq-webapp/src/lib/validations/user.ts`
- Router added to root: `grep -n "userRouter" sidekiq-webapp/src/server/api/root.ts`
- TypeScript compiles: `cd sidekiq-webapp && pnpm typecheck`
  </verify>
  <done>User preferences tRPC router created with getPreferences and updateModelPreferences</done>
</task>

<task type="auto">
  <name>Task 2: Create model selection hook and update chat route</name>
  <files>
    sidekiq-webapp/src/hooks/use-model-selection.ts
    sidekiq-webapp/src/app/api/chat/route.ts
  </files>
  <action>
Create hook for model selection state and update chat route to persist activeModel.

**1. Create useModelSelection hook** (sidekiq-webapp/src/hooks/use-model-selection.ts):
```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import { api } from "@sidekiq/trpc/react";
import { DEFAULT_MODEL, isValidModel } from "@sidekiq/lib/ai/models";

interface UseModelSelectionOptions {
  /** Initial model from thread (for existing threads) */
  threadModel?: string | null;
  /** Called when model changes (for tracking switches) */
  onModelChange?: (previousModel: string, newModel: string) => void;
}

interface UseModelSelectionReturn {
  /** Currently selected model ID */
  selectedModel: string;
  /** Change the selected model */
  setSelectedModel: (modelId: string) => void;
  /** User's favorite model IDs */
  favoriteModelIds: string[];
  /** User's default model ID */
  defaultModelId: string | undefined;
  /** Toggle a model's favorite status */
  toggleFavorite: (modelId: string) => void;
  /** Set a model as the user's default */
  setAsDefault: (modelId: string) => void;
  /** Whether preferences are loading */
  isLoading: boolean;
}

/**
 * Hook for managing model selection state with user preferences.
 *
 * Handles:
 * - Initial model from thread or user default
 * - Favorite toggling with optimistic updates
 * - Default model setting
 * - Model change tracking
 */
export function useModelSelection({
  threadModel,
  onModelChange,
}: UseModelSelectionOptions = {}): UseModelSelectionReturn {
  const utils = api.useUtils();

  // Fetch user preferences
  const { data: preferences, isLoading } = api.user.getPreferences.useQuery();

  // Mutation for updating preferences
  const updatePreferences = api.user.updateModelPreferences.useMutation({
    onMutate: async (input) => {
      // Cancel any outgoing refetches
      await utils.user.getPreferences.cancel();

      // Snapshot the previous value
      const previousPrefs = utils.user.getPreferences.getData();

      // Optimistically update
      if (previousPrefs) {
        const newPrefs = { ...previousPrefs };

        if (input.defaultModel !== undefined) {
          newPrefs.defaultModel = input.defaultModel;
        }

        if (input.toggleFavorite !== undefined) {
          const favorites = newPrefs.favoriteModels ?? [];
          if (favorites.includes(input.toggleFavorite)) {
            newPrefs.favoriteModels = favorites.filter((id) => id !== input.toggleFavorite);
          } else {
            newPrefs.favoriteModels = [...favorites, input.toggleFavorite];
          }
        }

        utils.user.getPreferences.setData(undefined, newPrefs);
      }

      return { previousPrefs };
    },
    onError: (_err, _input, context) => {
      // Rollback on error
      if (context?.previousPrefs) {
        utils.user.getPreferences.setData(undefined, context.previousPrefs);
      }
    },
    onSettled: () => {
      // Refetch after mutation
      void utils.user.getPreferences.invalidate();
    },
  });

  // Determine initial model: thread model > user default > system default
  const getInitialModel = useCallback(() => {
    if (threadModel && isValidModel(threadModel)) {
      return threadModel;
    }
    if (preferences?.defaultModel && isValidModel(preferences.defaultModel)) {
      return preferences.defaultModel;
    }
    return DEFAULT_MODEL;
  }, [threadModel, preferences?.defaultModel]);

  const [selectedModel, setSelectedModelState] = useState<string>(getInitialModel);

  // Update selected model when preferences load (for default model)
  useEffect(() => {
    if (!threadModel && preferences?.defaultModel && isValidModel(preferences.defaultModel)) {
      setSelectedModelState(preferences.defaultModel);
    }
  }, [threadModel, preferences?.defaultModel]);

  // Update selected model when thread model changes (navigating between threads)
  useEffect(() => {
    if (threadModel && isValidModel(threadModel)) {
      setSelectedModelState(threadModel);
    }
  }, [threadModel]);

  const setSelectedModel = useCallback(
    (modelId: string) => {
      if (!isValidModel(modelId)) return;

      const previousModel = selectedModel;
      setSelectedModelState(modelId);

      if (previousModel !== modelId) {
        onModelChange?.(previousModel, modelId);
      }
    },
    [selectedModel, onModelChange]
  );

  const toggleFavorite = useCallback(
    (modelId: string) => {
      updatePreferences.mutate({ toggleFavorite: modelId });
    },
    [updatePreferences]
  );

  const setAsDefault = useCallback(
    (modelId: string) => {
      updatePreferences.mutate({ defaultModel: modelId });
    },
    [updatePreferences]
  );

  return {
    selectedModel,
    setSelectedModel,
    favoriteModelIds: preferences?.favoriteModels ?? [],
    defaultModelId: preferences?.defaultModel,
    toggleFavorite,
    setAsDefault,
    isLoading,
  };
}
```

**2. Update /api/chat route** to persist activeModel:

In `sidekiq-webapp/src/app/api/chat/route.ts`, make these modifications:

**A. Update new thread creation (search for `.insert(threads)`)**:
Find the section that creates a new thread. Search for pattern: `db.insert(threads).values`
Add `activeModel: modelId` to the values object:

```typescript
// Find this pattern in the file:
// await db.insert(threads).values({
//   id: newThreadId,
//   userId: session.user.id,
//   ...
// })

// Add activeModel to the values:
await db.insert(threads).values({
  id: newThreadId,
  userId: session.user.id,
  title: null,
  activeModel: modelId,  // <-- ADD THIS LINE
  lastActivityAt: new Date(),
})
```

**B. Update existing thread on message save (search for `.update(threads)`)**:
Find the section that updates the thread after saving messages. Search for pattern: `db.update(threads).set`
Add `activeModel: modelId` to the set object:

```typescript
// Find this pattern in the file:
// await db.update(threads).set({
//   lastActivityAt: new Date(),
//   messageCount: ...
// })

// Add activeModel to the set:
await db.update(threads).set({
  lastActivityAt: new Date(),
  messageCount: thread.messageCount + 2,
  activeModel: modelId,  // <-- ADD THIS LINE
})
```

**C. Ensure modelId is extracted from request body**:
Near the top of the POST handler, search for pattern: `body.threadId` or similar body extraction.
Ensure the model is extracted from the request:

```typescript
// Find where threadId is extracted from body:
// const { threadId } = body;

// Should also extract model (may already exist):
const { threadId, model: modelId = DEFAULT_MODEL } = body;
```
  </action>
  <verify>
- Hook file exists: `ls sidekiq-webapp/src/hooks/use-model-selection.ts`
- Hook exports useModelSelection: `grep -n "export function useModelSelection" sidekiq-webapp/src/hooks/use-model-selection.ts`
- Chat route has activeModel in insert: `grep -n "activeModel" sidekiq-webapp/src/app/api/chat/route.ts`
- Chat route has activeModel in update: `grep -A5 "update(threads)" sidekiq-webapp/src/app/api/chat/route.ts | grep activeModel`
- TypeScript compiles: `cd sidekiq-webapp && pnpm typecheck`
  </verify>
  <done>useModelSelection hook created and chat route persists activeModel</done>
</task>

<task type="auto">
  <name>Task 3: Integrate model picker into chat interface</name>
  <files>
    sidekiq-webapp/src/components/chat/chat-interface.tsx
    sidekiq-webapp/src/components/chat/chat-input.tsx
    sidekiq-webapp/src/components/chat/model-switch-hint.tsx
  </files>
  <action>
Wire model picker into the chat UI with model switch hints.

**1. Create model switch hint component** (sidekiq-webapp/src/components/chat/model-switch-hint.tsx):
```typescript
import { Separator } from "@sidekiq/components/ui/separator";
import { getModelConfig } from "@sidekiq/lib/ai/models";

interface ModelSwitchHintProps {
  previousModel: string;
  currentModel: string;
}

/**
 * Inline hint showing when the model was switched mid-conversation.
 * Displayed as a subtle divider with model names.
 */
export function ModelSwitchHint({ previousModel, currentModel }: ModelSwitchHintProps) {
  const prevConfig = getModelConfig(previousModel);
  const currConfig = getModelConfig(currentModel);

  return (
    <div className="flex items-center gap-3 py-3">
      <Separator className="flex-1" />
      <span className="text-muted-foreground text-xs">
        Switched from {prevConfig?.name ?? previousModel} to {currConfig?.name ?? currentModel}
      </span>
      <Separator className="flex-1" />
    </div>
  );
}
```

**2. Update ChatInput** to accept model picker slot (sidekiq-webapp/src/components/chat/chat-input.tsx):

Find the ChatInputProps interface (search for `interface ChatInputProps`) and add:
```typescript
interface ChatInputProps {
  // ... existing props
  /** Model picker component to render */
  modelPicker?: React.ReactNode;
}
```

In the component function parameters, destructure the new prop:
```typescript
export function ChatInput({
  // ... existing props
  modelPicker,
}: ChatInputProps) {
```

Find the submit button container (search for `<Button type="submit"` or similar send button).
Add the model picker slot before the send/stop buttons. Look for the bottom-right control area:
```typescript
<div className="absolute right-2 bottom-2 flex items-center gap-2">
  {/* Add model picker slot */}
  {modelPicker}

  {/* Existing send/stop button code */}
  {isStreaming ? (
    // ... stop button
  ) : (
    // ... send button
  )}
</div>
```

**3. Update ChatInterface** to use model selection (sidekiq-webapp/src/components/chat/chat-interface.tsx):

**A. Add imports at the top:**
```typescript
import { ModelPicker } from "@sidekiq/components/model-picker";
import { ModelSwitchHint } from "./model-switch-hint";
import { useModelSelection } from "@sidekiq/hooks/use-model-selection";
```

**B. Update props interface (search for `interface ChatInterfaceProps`):**
```typescript
interface ChatInterfaceProps {
  threadId: string | null;
  initialMessages?: UIMessage[];
  initialTitle?: string | null;
  /** Initial model from thread (for existing threads) */
  initialModel?: string | null;
}
```

**C. Add state for model tracking inside the component (after existing useState calls):**
```typescript
// Track model switches for inline hints
const [modelSwitches, setModelSwitches] = useState<Array<{
  afterMessageIndex: number;
  previousModel: string;
  currentModel: string;
}>>([]);

// Track the model used for the most recent message
const lastMessageModelRef = useRef<string | null>(null);
```

**D. Add useModelSelection hook (search for existing hooks like useChat):**
```typescript
const {
  selectedModel,
  setSelectedModel,
  favoriteModelIds,
  defaultModelId,
  toggleFavorite,
} = useModelSelection({
  threadModel: initialModel,
  onModelChange: (previousModel, newModel) => {
    // Only add hint if there are existing messages
    if (messages.length > 0 && lastMessageModelRef.current) {
      setModelSwitches((prev) => [
        ...prev,
        {
          afterMessageIndex: messages.length - 1,
          previousModel,
          currentModel: newModel,
        },
      ]);
    }
  },
});
```

**E. Update handleSubmit to pass model (search for `handleSubmit` or `onSubmit` function):**

The key insight: `sendMessage` from useChat accepts an options object with a `body` property.
This body gets merged with the transport body and sent to the API.

Find the submit handler and update it:
```typescript
const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  const trimmedInput = input.trim();
  if (!trimmedInput || isStreaming) return;

  setInput("");
  lastMessageModelRef.current = selectedModel;

  // Pass model in the options.body - this merges with transport.body
  await sendMessage(
    { text: trimmedInput },
    { body: { model: selectedModel } }  // <-- This is how model gets to API
  );
};
```

**F. Add model picker to ChatInput (search for `<ChatInput` component usage):**
```typescript
<ChatInput
  input={input}
  setInput={setInput}
  onSubmit={handleSubmit}
  isStreaming={isStreaming}
  onStop={stop}
  modelPicker={
    <ModelPicker
      value={selectedModel}
      onValueChange={setSelectedModel}
      favoriteModelIds={favoriteModelIds}
      defaultModelId={defaultModelId}
      onToggleFavorite={toggleFavorite}
      disabled={isStreaming}
    />
  }
/>
```

**G. (Optional) Render model switch hints in message list:**
If you want to show hints between messages, update the message rendering area to include hints at the appropriate indices.
  </action>
  <verify>
- ModelSwitchHint exists: `ls sidekiq-webapp/src/components/chat/model-switch-hint.tsx`
- ModelPicker imported in ChatInterface: `grep -n "ModelPicker" sidekiq-webapp/src/components/chat/chat-interface.tsx`
- useModelSelection used: `grep -n "useModelSelection" sidekiq-webapp/src/components/chat/chat-interface.tsx`
- Model passed via sendMessage body: `grep -n "body.*model.*selectedModel" sidekiq-webapp/src/components/chat/chat-interface.tsx`
- modelPicker prop in ChatInput: `grep -n "modelPicker" sidekiq-webapp/src/components/chat/chat-input.tsx`
- TypeScript compiles: `cd sidekiq-webapp && pnpm typecheck`
- Dev server runs: `cd sidekiq-webapp && pnpm dev` (manual check)
  </verify>
  <done>Model picker integrated into chat interface with model switch hints</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd sidekiq-webapp && pnpm typecheck` - No type errors
2. `cd sidekiq-webapp && pnpm lint` - No lint errors
3. `cd sidekiq-webapp && pnpm build` - Build succeeds
4. Manual testing:
   - Model picker appears below chat input
   - Selecting a model and sending message uses that model
   - Refreshing page shows thread's last used model
   - Favoriting a model persists across sessions
   - Setting default model affects new threads
   - Switching model mid-conversation shows inline hint
</verification>

<success_criteria>
- Model picker visible below chat input, bottom-right side
- Picker disabled during streaming
- Selected model passed to /api/chat via sendMessage's body option (body: { model: selectedModel })
- Thread activeModel updated on each message
- User preferences (favorites, default) persist via tRPC
- Favorites show optimistic updates with rollback on error
- Model switch creates inline hint in chat
- Returning to a thread shows thread's last used model in picker
- New threads use user's default model (or system default)
</success_criteria>

<output>
After completion, create `.planning/phases/04-model-selection/04-03-SUMMARY.md`
</output>
